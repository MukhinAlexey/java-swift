options
{

     LOOKAHEAD=3;
     DEBUG_PARSER = true;
}

PARSER_BEGIN(JavaSwift)

import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class JavaSwift
{
    public static void main(String args[]) throws FileNotFoundException, ParseException
    {
        JavaSwift parser = new JavaSwift(new FileInputStream(args[0]));
        parser.TopLevelDeclaration();
    }
}

PARSER_END(JavaSwift)

SKIP:
{
    " "
  | "\t"
  | "\n"
  | "\r"
  | <"//" (~["\n","\r"])* ("\n"|"\r")>
}

TOKEN:
{

    < UPPER_LETTER: ["A"-"Z"] >
    | < LOWER_LETTER: ["a"-"z"] >
    | < UNDERSCORE: "_" >
    | < EXTENDED_UNICODE: ("\u00A8") | ("\u00AA") | ("\u00AD") | ("\u00AF") | (["\u00B2"-"\u00B5"]) | (["\u00B7"-"\u00BA"])
    | (["\u00BC"-"\u00BE"]) | (["\u00C0"-"\u00D6"]) | (["\u00D8"-"\u00F6"]) | (["\u00F8"-"\u00FF"])
    | (["\u0100"-"\u02FF"]) | (["\u0370"-"\u167F"]) | (["\u1681"-"\u180D"]) | (["\u180F"-"\u1DBF"])
    | (["\u1E00"-"\u1FFF"])
    | (["\u200B"-"\u200D"]) | (["\u202A"-"\u202E"]) | (["\u203F"-"\u2040"]) | ("\u2054") | (["\u2060"-"\u206F"])
    | (["\u2070"-"\u20CF"]) | (["\u2100"-"\u218F"]) | (["\u2460"-"\u24FF"]) | (["\u2776"-"\u2793"])
    | (["\u2C00"-"\u2DFF"]) | (["\u2E80"-"\u2FFF"])
    | (["\u3004"-"\u3007"]) | (["\u3021"-"\u302F"]) | (["\u3031"-"\u303F"]) | (["\u3040"-"\uD7FF"])
    | (["\uF900"-"\uFD3D"]) | (["\uFD40"-"\uFDCF"]) | (["\uFDF0"-"\uFE1F"]) | (["\uFE30"-"\uFE44"])
    | (["\uFE47"-"\uFFFD"]) >
    // | < EXTENDED_UNICODE: (["\u10000"-"\u1FFFD"]) | (["\u20000"-"\u2FFFD"]) | (["\u30000"-"\u3FFFD"]) | (["\u40000"-"\u4FFFD"]) >
    // | < EXTENDED_UNICODE: (["\u50000"-"\u5FFFD"]) | (["\u60000"-"\u6FFFD"]) | (["\u70000"-"\u7FFFD"]) | (["\u80000"-"\u8FFFD"]) >
    // | < EXTENDED_UNICODE: (["\u90000"-"\u9FFFD"]) | (["\uA0000"-"\uAFFFD"]) | (["\uB0000"-"\uBFFFD"]) | (["\uC0000"-"\uCFFFD"]) >
    // | < EXTENDED_UNICODE: (["\uD0000"-"\uDFFFD "]) | (["\uE0000"-"\uEFFFD"]) >

    | < EXTENDED_UNICODE_2: (["\u0300"-"\u036F"]) | (["\u1DC0"-"\u1DFF"]) | (["\u20D0"-"\u20FF"]) | (["\uFE20"-"\uFE2F"]) >


    //ToDo: почему на первой строке первый слэш не экранируется, а на второй у \\u экранируется?
    | < ESCAPE_CHARACTERS: ("\\0") | ("\\") | ("\t") | ("\n") | ("\r") | ("\"") | ("\'")
    | ("\\u") (<OPEN_BRACKET>) (["1"-"8"]) (<CLOSED_BRACKET>) >

    | < SURROGATE_PAIR_CODE: (["\uD800"-"\uDFFF"]) >
    //| < UNICODE_SCALAR: (["\u0000"-"\uD7FF"]) >

    /* ================================
                    Digits
       ================================ */
    | < DIGIT: ["0"-"9"] >

    | < BINARY_DIGIT_BEGIN: "0b" >
    | < BINARY_DIGIT: ["0"-"1"] >

    | < OCTAL_DIGIT_BEGIN: "0o" >
    | < OCTAL_DIGIT: ["0"-"7"] >
    | < DECIMAL_DIGIT: (<DIGIT>)>

    | < HEXADECIMAL_DIGIT_BEGIN: "0x">
    | < HEXADECIMAL_DIGIT: (<DECIMAL_DIGIT>) | (["a"-"f"]) | (["A"-"F"]) >


    /* ================================
                    Math
       ================================ */
    | < PLUS: "+" >
    | < MINUS: "-" >
    | < ASSIGN: "=" >
    | < E: ("E") | ("e") >
    | < P: ("P") | ("p") >
    | <STAR: "*" >
    | <PERCENT: "%" >
    | <MORE_OR_EQUALS: ">=" >
    | <LESS_OR_EQUALS: "<=" >
    | <EQUALS: "==" >

    /* ================================
                    Literals
       ================================ */
    | < TRUE: "true">
    | < FALSE: "false">
    | < NIL: "nil">
    | < SHARP_FILE: "#file" >
    | < SHARP_LINE: "#line" >
    | < COLUMN: "#column" >
    | < FUNCTION: "#function" >
    | < COLOR_LITERAL: "#colorLiteral" >
    | < RED: "red" >
    | < GREEN: "green" >
    | < BLUE: "blue" >
    | < ALPHA: "alpha" >
    | < FILE_LITERAL: "#fileLiteral" >
    | < IMAGE_LITERAL: "#imageLiteral" >
    | < RESOURCE_NAME: "resourceName" >


    /* ================================
                    Operators
       ================================ */
    | < OPERATOR_HEAD: (["\u00A1"-"\u00A7"])
    | ("\u00A9") | ("\u00AB")
    | ("\u00AC ") | ("\u00AE")
    | (["\u00B0"-"\u00B1"]) | ("\u00B6 ") | ("\u00BB") | ("\u00BF ") | ("\u00D7") | ("\u00F7")
    | (["\u2016"-"\u2017"]) | (["\u2020"-"\u2027"])
    | (["\u2030"-"\u203E"])
    | (["\u2041"-"\u2053"])
    | (["\u2055"-"\u205E"])
    | (["\u2190"-"\u23FF"])
    | (["\u2500"-"\u2775"])
    | (["\u2794"-"\u2BFF"])
    | (["\u2E00"-"\u2E7F"])
    | (["\u3001"-"\u3003"])
    | (["\u3008"-"\u3030"])
    | <PLUS>
    | <MINUS>
    | <ASSIGN>
    | <SLASH>
    | <EXCLAMATION_MARK>
    | <STAR>
    | <PERCENT>
    | <OPEN_TRIANGULAR_BRACKET>
    | <CLOSED_TRIANGULAR_BRACKET>
    | <AMPERSAND>
    | <OR>
    | <AMPERSAND>
    | ("^")
    | ("~")
    | <QUESTION_MARK> >



    | < OPERATOR_CHARACTER: (["\u0300"-"\u036F"])
    | (["\u1DC0"-"\u1DFF"])
    | (["\u20D0"-"\u20FF"])
    | (["\uFE00"-"\uFE0F"])
    | (["\uFE20"-"\uFE2F"]) >
    //| < OPERATOR_CHARACTER: (["\uE0100"-"\uE01EF"]) >


    /* ================================
                    Types
       ================================ */
    | < ANY: "any" >
    | < ARROW_RIGHT: "->">


    /* ================================
                    Annotation
       ================================ */
    | < INOUT: "inout" >


    /* ================================
                    Annotation
       ================================ */
    | < THROWS: "throws">
    | < RETHROWS: "rethrows">


    /* ================================
                    Metatype
       ================================ */
    | < CAPITAL_TYPE: "Type" >
    | < CAPITAL_PROTOCOL: "Protocol">


    /* ================================
                    Type Inheritance
       ================================ */
    | < CLASS: "class" >


    /* ================================
                    Try
       ================================ */
    | < TRY: "try" >


    /* ================================
                    Type-Casting
       ================================ */
    | < AS: "as" >
    | < IS: "is" >

    /* ================================
                    Self
       ================================ */
    | < SELF: "self" >
    | < INIT: "init" >


    /* ================================
                    Superclass
       ================================ */
    | < SUPER: "super" >


    /* ================================
                    Closure
       ================================ */
    | < IN: "in" >
    | < WEAK: "weak" >
    | < UNOWNED: "unowned" >
    | < SAFE: "safe" >
    | < UNSAFE: "unsafe" >


    /* ================================
                    Selector
       ================================ */
    | < SELECTOR: "#selector" >
    | < GETTER: "getter:" >
    | < SETTER: "setter:" >


    /* ================================
                    Key-Path
       ================================ */
    | < KEY_PATH: "#keyPath" >


    /* ================================
                    Dynamic Type
       ================================ */
    | < TYPE: "type" >
    | < OF: "of" >


    /* ================================
                    Dynamic Type
       ================================ */
    | < LET: "let" >
    | < VAR: "var" >


    /* ================================
                    Loops
       ================================ */
    | < WHILE: "while" >
    | < FOR: "for" >
    | < CASE: "case" >
    | < REPEAT: "repeat" >
    | < BREAK: "break" >
    | < CONTINUE: "continue" >


    /* ================================
                    Conditions
       ================================ */
    | < IF: "if" >
    | < ELSE: "else" >
    | < SWITCH: "switch" >
    | < DEFAULT_1: "default" >
    | < WHERE: "where" >


    /* ================================
                    Guard
       ================================ */
    | < GUARD: "guard" >


    /* ================================
                    Fallthrough
       ================================ */
    | < FALLTHROUGH: "fallthrough" >
    
    
    /* ================================
                    Return
       ================================ */
    | < RETURN: "return" >
    
    
    /* ================================
                    Throw
       ================================ */
    | < THROW: "throw" >
    
    
    /* ================================
                    Defer
       ================================ */
    | < DEFER: "defer" >
    
    
    /* ================================
                    Do
       ================================ */
    | < DO: "do" >
    | < CATCH: "catch" >
    
    
    /* ================================
                    Conditional Compilation
       ================================ */
    | < SHARP_IF: "#if" >
    | < SHARP_ELSEIF: "#elseif" >
    | < SHARP_ELSE: "#else" >
    | < SHARP_ENDIF: "#endif" >
    | < OS: "os" >
    | < ARCH: "arch" >
    | < SWIFT: "swift" >
    | < MAC_OS: "macOS" >
    | < IOS: "iOS" >
    | < WATCH_OS: "watchOS" >
    | < TV_OS: "tvOS" >
    | < I_386: "i386" >
    | < X_86_64: "x86_64" >
    | < ARM: "arm" >
    | < ARM_64: "arm64" >
    
    
    /* ================================
                    Line Control
       ================================ */
    | < SOURCE_LOCATION: "#sourceLocation" >
    | < FILE: "file:" >
    | < LINE: "line:" >


    /* ================================
                    Availability
       ================================ */
    | < SHARP_AVAILABLE: "#available" >
    | < IOS_APP_EXT: "iOSApplicationExtension" >
    | < MAC_OS_APP_EXT: "macOSApplicationExtension" >


    /* ================================
                    Import
       ================================ */
    | < IMPORT: "import" >
    | < TYPE_ALIAS: "typealias" >
    | < ENUM: "enum" >
    | < PROTOCOL: "protocol" >
    | < FUNC: "func" >


    /* ================================
                    Variable
       ================================ */
    | < GET: "get" >
    | < SET: "set" >
    | < WILL_SET: "willSet" >
    | < DID_SET: "didSet" >


    /* ================================
                    Enumeration
       ================================ */
    | < INDIRECT: "indirect" >


    /* ================================
                    Structure
       ================================ */
    | < STRUCT: "struct" >


    /* ================================
                    Class
       ================================ */
    | < FINAL: "final" >


    /* ================================
                    Associated Type
       ================================ */
    | < ASSOCIATED_TYPE: "associatedtype" >


    /* ================================
                    Deinitializer
       ================================ */
    | < DEINIT: "deinit" >


    /* ================================
                    Extension
       ================================ */
    | < EXTENSION: "extension" >


    /* ================================
                    Subscript
       ================================ */
    | < SUBSCRIPT: "subscript" >


    /* ================================
                    Operators
       ================================ */
    | < PREFIX: "prefix" >
    | < POSTFIX: "postfix" >
    | < OPERATOR: "operator" >


    /* ================================
                    Precedence Group
       ================================ */
    | < PRECEDENCE_GROUP: "precedencegroup" >
    | < HIGHER_THAN: "higherThan" >
    | < LOWER_THAN: "lowerThan" >
    | < ASSIGNMENT: "assignment" >
    | < ASSOCIATIVITY: "associativity" >
    | < LEFT: "left" >
    | < RIGHT: "right" >
    | < NONE: "none" >


    /* ================================
                    Declaration
       ================================ */
    | < CONVENIENCE: "convenience" >
    | < DYNAMIC: "dynamic" >
    | < INFIX: "infix" >
    | < LAZY: "lazy" >
    | < OPTIONAL: "optional" >
    | < OVERRIDE: "override" >
    | < REQUIRED: "required" >
    | < STATIC: "static" >
    | < PRIVATE: "private" >
    | < FILEPRIVATE: "fileprivate"  >
    | < INTERNAL: "internal" >
    | < PUBLIC: "public" >
    | < OPEN: "open" >
    | < MUTATING: "mutating" >
    | < NON_MUTATING: "nonmutating" >


    /* ================================
                    Punctuation
       ================================ */
    | < DOT: "." >
    | < THREE_DOTS: "...">
    | < COMMA: "," >
    | < SEMICOLON: ";" >
    | < COLON: ":" >
    | < QUESTION_MARK: "?" >
    | < EXCLAMATION_MARK: "!" >
    | < SLASH: "/" >
    | < BACK_SLASH: "\\" >
    | < DOLLAR: "$" >
    | < AMPERSAND: "&" >
    | < DBL_AMPERSAND: "&&" >
    | < OR: "|" >
    | < DBL_OR: "||" >
    | < AT: "@" >


    /* ================================
                    Brackets
       ================================ */
    | < OPEN_BRACKET: "{" >
    | < CLOSED_BRACKET: "}" >
    | < OPEN_SQUARE_BRACKET: "[" >
    | < CLOSED_SQUARE_BRACKET: "]" >
    | < OPEN_DOUBLE_QUOTE: "\"" >
    | < OPEN_PARENTHESIS: "(" >
    | < CLOSED_PARENTHESIS: ")" >
    | < OPEN_QUOTE: "`" >
    | < OPEN_TRIANGULAR_BRACKET: "<" >
    | < CLOSED_TRIANGULAR_BRACKET: ">" >



}

/* =====================================================================================================================
                        1. Lexical Structure
   ================================================================================================================== */

/* ===================================================================
                        1.1. GRAMMAR OF AN IDENTIFIER (CHECKED by Alexey)
   =================================================================== */

//Проверено
void Identifier(): {}
{
    IdentifierHead() (IdentifierCharacters())?
    | <OPEN_QUOTE> IdentifierHead() (IdentifierCharacter())? <OPEN_QUOTE>
    | ImplicitParameterName()
}

//Проверено
void IdentifierList(): {}
{
    Identifier()
    | Identifier() <COMMA> IdentifierList()
}

//Проверено
void IdentifierHead(): {}
{
    <UPPER_LETTER>
    | <LOWER_LETTER>
    | <UNDERSCORE>
    | <EXTENDED_UNICODE>
}

//Проверено
void IdentifierCharacter(): {}
{
    <DIGIT>
    | IdentifierHead()
    | <EXTENDED_UNICODE_2>
}

//Проверено
void IdentifierCharacters(): {}
{
    IdentifierCharacter() (IdentifierCharacters())?
}

//Проверено
void ImplicitParameterName(): {}
{
    <DOLLAR> <DECIMAL_DIGIT>
}

/* ===================================================================
                        1.2. GRAMMAR OF A LITERAL (CHECKED by Alexey)
   =================================================================== */

//Проверено
void Literal(): {}
{
    NumericLiteral()
    | StringLiteral()
    | BooleanLiteral()
    | NilLiteral()
}

//Проверено
void NumericLiteral(): {}
{
    (<MINUS>)? IntegerLiteral()
    | (<MINUS>)? FloatingPointLiteral()
}

//Проверено
void BooleanLiteral(): {}
{
    <TRUE>
    | <FALSE>
}

//Проверено
void NilLiteral(): {}
{
    <NIL>
}

/* ===================================================================
                        1.3. GRAMMAR OF AN INTEGER LITERAL (CHECKED by Alexey)
   =================================================================== */

//Проверено
void IntegerLiteral(): {}
{
    BinaryLiteral()
    | OctalLiteral()
    | DecimalLiteral()
    | HexadecimalLiteral()
}

//Проверено
void BinaryLiteral(): {}
{
    <BINARY_DIGIT_BEGIN> <BINARY_DIGIT> (BinaryLiteralCharacters())?
}


//Проверено
void BinaryLiteralCharacter(): {}
{
    <BINARY_DIGIT>
    | <UNDERSCORE>
}

//Проверено
void BinaryLiteralCharacters(): {}
{
    BinaryLiteralCharacter() (BinaryLiteralCharacters())?
}

//Проверено
void OctalLiteral(): {}
{
    <OCTAL_DIGIT_BEGIN> <OCTAL_DIGIT> (OctalLiteralCharacters())?
}

//Проверено
void OctalLiteralCharacter(): {}
{
    <OCTAL_DIGIT>
    | <UNDERSCORE>
}

//Проверено
void OctalLiteralCharacters(): {}
{
    OctalLiteralCharacter() (OctalLiteralCharacters())?
}

//Проверено
void DecimalLiteral(): {}
{
    <DECIMAL_DIGIT> (DecimalLiteralCharacter())?
}

//Проверено
void DecimalDigits(): {}
{
    <DECIMAL_DIGIT> (DecimalDigits())?
}

//Проверено
void DecimalLiteralCharacter(): {}
{
    <DECIMAL_DIGIT>
    | <UNDERSCORE>
}

//Проверено
void DecimalLiteralCharacters(): {}
{
    DecimalLiteralCharacter() (DecimalLiteralCharacters())?
}

//Проверено
void HexadecimalLiteral(): {}
{
    <HEXADECIMAL_DIGIT_BEGIN> <HEXADECIMAL_DIGIT> (HexadecimalLiteralCharacters())?
}

//Проверено
void HexadecimalLiteralCharacter(): {}
{
    <HEXADECIMAL_DIGIT>
    | <UNDERSCORE>
}

//Проверено
void HexadecimalLiteralCharacters(): {}
{
    HexadecimalLiteralCharacter() (HexadecimalLiteralCharacters())?
}

/* ===================================================================
                        1.4. GRAMMAR OF A FLOATING-POINT LITERAL (CHECKED by Alexey)
   =================================================================== */

//Проверено
void FloatingPointLiteral(): {}
{
    DecimalLiteral() (DecimalFraction())? (DecimalExponent())?
    | HexadecimalLiteral() (HexadecimalFraction())? HexadecimalExponent()
}

//Проверено
void DecimalFraction(): {}
{
    <DOT> DecimalLiteral()
}

//Проверено
void DecimalExponent(): {}
{
    <E> (<PLUS> | <MINUS>)? DecimalLiteral()
}

//Проверено
void HexadecimalFraction(): {}
{
    <DOT> <HEXADECIMAL_DIGIT> (HexadecimalLiteralCharacters())?
}

//Проверено
void HexadecimalExponent(): {}
{
    <P> (<PLUS> | <MINUS>)? DecimalLiteral()
}

/* ===================================================================
                        1.5. GRAMMAR OF A STRING LITERAL (CHECKED by Alexey)
   =================================================================== */

//Проверено
void StringLiteral(): {}
{
    StaticStringLiteral()
    | InterpolatedStringLiteral()
}

//Проверено
void StaticStringLiteral(): {}
{
    <OPEN_DOUBLE_QUOTE> (QuotedText())? <OPEN_DOUBLE_QUOTE>
}

//Проверено
void QuotedText(): {}
{
    QuotedTextItem() (QuotedText())?
}


// TODO: Any Unicode scalar value except ", \, u000A, u000D
void QuotedTextItem(): {}
{
//    <UNICODE_SCALAR>
    <ESCAPE_CHARACTERS>
}

//Проверено
void InterpolatedStringLiteral(): {}
{
    <OPEN_DOUBLE_QUOTE> (InterpolatedText())? <OPEN_DOUBLE_QUOTE>
}

//Проверено
void InterpolatedText(): {}
{
    InterpolatedTextItem() (InterpolatedText())?
}

//Проверено
void InterpolatedTextItem(): {}
{
    <BACK_SLASH> <OPEN_PARENTHESIS> Expression() <CLOSED_PARENTHESIS>
    | QuotedTextItem()
}

/* ===================================================================
                        1.6. GRAMMAR OF OPERATORS
   =================================================================== */

void Operator(): {}
{
    OperatorHead() (OperatorCharacters())?
    | <DOT> DotOperatorCharacters()
}

void OperatorHead(): {}
{
    <OPERATOR_HEAD>
}

void OperatorCharacter(): {}
{
    OperatorHead()
    | <OPERATOR_CHARACTER>
}

void OperatorCharacters(): {}
{
    OperatorCharacter() (OperatorCharacters())?
}

void DotOperatorCharacter(): {}
{
    <DOT>
    | OperatorCharacter()
}

void DotOperatorCharacters(): {}
{
    DotOperatorCharacter() (DotOperatorCharacters())?
}

void BinaryOperator(): {}
{
    Operator()
}

void PrefixOperator(): {}
{
    Operator()
}

void PostfixOperator(): {}
{
    Operator()
}

/* =====================================================================================================================
                        2. Types
   ================================================================================================================== */

/* ===================================================================
                        2.1. GRAMMAR OF A TYPE
   =================================================================== */

// TODO: Не понял, где type → ( type ), но я его добавил
void Type(): {}
{
    (   ArrayType()
        | DictionaryType()
        | FunctionType()
        | TypeIdentifier()
        | TupleType()
        | ProtocolCompositionType()
        | <ANY>
        | <SELF>
        | <OPEN_PARENTHESIS> Type() <CLOSED_PARENTHESIS>
    ) (SimpleType())?
}

void SimpleType(): {}
{
    (   OptionalType()
        | ImplicitlyUnwrappedOptionalType()
        | MetatypeType()
    ) (SimpleType())?
}

/* ===================================================================
                        2.2. GRAMMAR OF A TYPE ANNOTATION (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void TypeAnnotation(): {}
{
    <COLON> (Attributes())? (<INOUT>)? Type()
}

/* ===================================================================
                        2.3. GRAMMAR OF A TYPE IDENTIFIER (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void TypeIdentifier(): {}
{
    TypeName() (GenericArgumentClause())?
    | TypeName() (GenericArgumentClause())? <DOT> TypeIdentifier()
}

// ПРОВЕРЕНО
void TypeName(): {}
{
    Identifier()
}

/* ===================================================================
                        2.4. GRAMMAR OF A TUPLE TYPE (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void TupleType(): {}
{
    <OPEN_PARENTHESIS> (TupleTypeElementList())? <CLOSED_PARENTHESIS>
}

// ПРОВЕРЕНО
void TupleTypeElementList(): {}
{
    TupleTypeElement()
    | TupleTypeElement() <COMMA> TupleTypeElementList()
}

// ПРОВЕРЕНО
void TupleTypeElement(): {}
{
    ElementName() TypeAnnotation()| Type()
}

// ПРОВЕРЕНО
void ElementName(): {}
{
    Identifier()
}

/* ===================================================================
                        2.5. GRAMMAR OF A FUNCTION TYPE (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void FunctionType(): {}
{
    (Attributes())? FunctionTypeArgumentClause() (<THROWS>)? <ARROW_RIGHT> Type()
    | (Attributes())? FunctionTypeArgumentClause() <RETHROWS> <ARROW_RIGHT> Type()
}

// ПРОВЕРЕНО, исправлена ошибка
void FunctionTypeArgumentClause(): {}
{
    <OPEN_PARENTHESIS> <CLOSED_PARENTHESIS> |
    <OPEN_PARENTHESIS> FunctionTypeArgumentList() (<THREE_DOTS>)? <CLOSED_PARENTHESIS>
}

// ПРОВЕРЕНО
void FunctionTypeArgumentList(): {}
{
    FunctionTypeArgument() |
    FunctionTypeArgument() <COMMA> FunctionTypeArgumentList()
}

// ПРОВЕРЕНО
void FunctionTypeArgument(): {}
{
    (Attributes())? (<INOUT>)? Type() |
    ArgumentLabel() TypeAnnotation()
}

// ПРОВЕРЕНО
void ArgumentLabel(): {}
{
    Identifier()
}

/* ===================================================================
                        2.6. GRAMMAR OF AN ARRAY TYPE (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void ArrayType(): {}
{
    <OPEN_SQUARE_BRACKET> Type() <CLOSED_SQUARE_BRACKET>
}

/* ===================================================================
                        2.7. GRAMMAR OF A DICTIONARY TYPE (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void DictionaryType(): {}
{
    <OPEN_SQUARE_BRACKET> Type() <COLON> Type() <CLOSED_SQUARE_BRACKET>
}

/* ===================================================================
                        2.8. GRAMMAR OF AN OPTIONAL TYPE (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО, исправлена ошибка
void OptionalType(): {}
{
    Type() <QUESTION_MARK>
}

/* ===================================================================
                        2.9. GRAMMAR OF AN IMPLICITLY UNWRAPPED OPTIONAL TYPE (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО, исправлена ошибка
void ImplicitlyUnwrappedOptionalType(): {}
{
    Type() <EXCLAMATION_MARK>
}

/* ===================================================================
                        2.10. GRAMMAR OF A PROTOCOL COMPOSITION TYPE (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void ProtocolCompositionType(): {}
{
    ProtocolIdentifier() <AMPERSAND> ProtocolCompositionContinuation()
}

// ПРОВЕРЕНО, исправлена ошибка
void ProtocolCompositionContinuation(): {}
{
    ProtocolIdentifier()
    | ProtocolCompositionType()
}

// ПРОВЕРЕНО
void ProtocolIdentifier(): {}
{
    TypeIdentifier()
}

/* ===================================================================
                        2.11. GRAMMAR OF A METATYPE TYPE (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО, исправлена ошибка
void MetatypeType(): {}
{
    Type() <DOT> <TYPE>
    | Type() <DOT> <CAPITAL_PROTOCOL>
}

/* ===================================================================
                        2.12. GRAMMAR OF A TYPE INHERITANCE CLAUSE (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void TypeInheritanceClause(): {}
{
    <COLON> <CLASS> <COMMA> TypeInheritanceList()
    | <COLON> <CLASS>
    | <COLON> TypeInheritanceList()
}

// ПРОВЕРЕНО
void TypeInheritanceList(): {}
{
    TypeIdentifier()
    | TypeIdentifier() <COMMA> TypeInheritanceList()
}

/* =====================================================================================================================
                        3. Expressions
   ================================================================================================================== */

/* ===================================================================
                        3.1. GRAMMAR OF AN EXPRESSION
   =================================================================== */

//Проверено
void Expression(): {}
{
    (TryOperator())? PrefixExpression() (BinaryExpressions())?
}

//Проверено
void ExpressionList(): {}
{
    Expression()
    | Expression() <COMMA> ExpressionList()
}

/* ===================================================================
                        3.2. GRAMMAR OF A PREFIX EXPRESSION
   =================================================================== */

//Проверено
void PrefixExpression(): {}
{
    (PrefixOperator())? PostfixExpression()
    | InOutExpression()
}

//Проверено
void InOutExpression(): {}
{
    <AMPERSAND> Identifier()
}


//Проверено
void TryOperator(): {}
{
    <TRY>
    | <TRY> <QUESTION_MARK>
    | <TRY> <EXCLAMATION_MARK>
}

/* ===================================================================
                        3.3. GRAMMAR OF A BINARY EXPRESSION
   =================================================================== */

//Проверено
void BinaryExpression(): {}
{
    BinaryOperator() PrefixExpression()
    | <ASSIGN> (TryOperator())? PrefixExpression()
    | ConditionalOperator() (TryOperator())? PrefixExpression()
    | TypeCastingOperator()
}

//Проверено
void BinaryExpressions(): {}
{
    BinaryExpression() (BinaryExpressions())?
}

/* ===================================================================
                        3.4. GRAMMAR OF A CONDITIONAL OPERATOR
   =================================================================== */

//Проверено
void ConditionalOperator(): {}
{
    <QUESTION_MARK> (TryOperator())? Expression() <COLON>
}

/* ===================================================================
                        3.5. GRAMMAR OF A TYPE-CASTING OPERATOR
   =================================================================== */

//Проверено
void TypeCastingOperator(): {}
{
    <IS> Type()
    | <AS> Type()
    | <AS> <QUESTION_MARK> Type()
    | <AS> <EXCLAMATION_MARK> Type()
}

/* ===================================================================
                        3.6. GRAMMAR OF A PRIMARY EXPRESSION
   =================================================================== */

//Проверено
void PrimaryExpression(): {}
{
    Identifier() (GenericArgumentClause())?
    | LiteralExpression()
    | SelfExpression()
    | SuperclassExpression()
    | ClosureExpression()
    | ParenthesizedExpression()
    | TupleExpression()
    | ImplicitMemberExpression()
    | WildcardExpression()
    | SelectorExpression()
    | KeyPathExpression()
}

/* ===================================================================
                        3.7. GRAMMAR OF A LITERAL EXPRESSION
   =================================================================== */

//Проверено
void LiteralExpression(): {}
{
    Literal()
    | ArrayLiteral()
    | DictionaryLiteral()
    | PlaygroundLiteral()
    | <SHARP_FILE>
    | <SHARP_LINE>
    | <COLUMN>
    | <FUNCTION>
}

//Проверено
void ArrayLiteral(): {}
{
    <OPEN_SQUARE_BRACKET> (ArrayLiteralItems())? <CLOSED_SQUARE_BRACKET>
}

//Проверено
void ArrayLiteralItems(): {}
{
    ArrayLiteralItem() (<COMMA>)?
    | ArrayLiteralItem() <COMMA> ArrayLiteralItems()
}

//Проверено
void ArrayLiteralItem(): {}
{
    Expression()
}

//Проверено
void DictionaryLiteral(): {}
{
    <OPEN_SQUARE_BRACKET> DictionaryLiteralItems() <CLOSED_SQUARE_BRACKET>
    | <OPEN_SQUARE_BRACKET> <COLON> <CLOSED_SQUARE_BRACKET>
}

//Проверено
void DictionaryLiteralItems(): {}
{
    DictionaryLiteralItem() (<COMMA>)?
    | DictionaryLiteralItem() <COMMA> DictionaryLiteralItems()
}

//Проверено
void DictionaryLiteralItem(): {}
{
    Expression() <COLON> Expression()
}

//Проверено
void PlaygroundLiteral(): {}
{
    <COLOR_LITERAL> <OPEN_PARENTHESIS> <RED> <COLON> Expression() <COMMA> <GREEN> <COLON> Expression() <COMMA> <BLUE> <COLON> Expression() <COMMA> <ALPHA> <COLON> Expression() <CLOSED_PARENTHESIS>
    | <FILE_LITERAL> <OPEN_PARENTHESIS> <RESOURCE_NAME> <COLON> Expression() <CLOSED_PARENTHESIS>
    | <IMAGE_LITERAL> <OPEN_PARENTHESIS> <RESOURCE_NAME> <COLON> Expression() <CLOSED_PARENTHESIS>
}

/* ===================================================================
                        3.8. GRAMMAR OF A SELF EXPRESSION
   =================================================================== */

//Проверено
void SelfExpression(): {}
{
    <SELF>
    | SelfMethodExpression()
    | SelfSubscriptExpression()
    | SelfInitializerExpression()
}

//Проверено
void SelfMethodExpression(): {}
{
    <SELF> <DOT> Identifier()
}

//Проверено
void SelfSubscriptExpression(): {}
{
    <SELF> <OPEN_SQUARE_BRACKET> ExpressionList() <CLOSED_SQUARE_BRACKET>
}

//Проверено
void SelfInitializerExpression(): {}
{
    <SELF> <DOT> <INIT>
}

/* ===================================================================
                        3.9. GRAMMAR OF A SUPERCLASS EXPRESSION (DONE)
   =================================================================== */

//Проверено
void SuperclassExpression(): {}
{
    SuperclassMethodExpression()
    | SuperclassSubscriptExpression()
    | SuperclassInitializerExpression()
}

//Проверено
void SuperclassMethodExpression(): {}
{
    <SUPER> <DOT> Identifier()
}

//Проверено
void SuperclassSubscriptExpression(): {}
{
    <SUPER> <OPEN_SQUARE_BRACKET> ExpressionList() <CLOSED_SQUARE_BRACKET>
}

//Проверено
void SuperclassInitializerExpression(): {}
{
    <SUPER> <DOT> <INIT>
}

/* ===================================================================
                        3.10. GRAMMAR OF A CLOSURE EXPRESSION
   =================================================================== */

//Проверено
void ClosureExpression(): {}
{
    <OPEN_BRACKET> (ClosureSignature())? (Statements())? <CLOSED_BRACKET>
}

//Проверено
void ClosureSignature(): {}
{
    (CaptureList())? ClosureParameterClause() (<THROWS>)? (FunctionResult())? <IN>
    | CaptureList() <IN>
}

//Проверено
void ClosureParameterClause(): {}
{
    <OPEN_PARENTHESIS> <CLOSED_PARENTHESIS>
    | <OPEN_PARENTHESIS> ClosureParameterList() <CLOSED_PARENTHESIS>
    | IdentifierList()
}

//Проверено
void ClosureParameterList(): {}
{
    ClosureParameter()
    | ClosureParameter() <COMMA> ClosureParameterList()
}

//Проверено
void ClosureParameter(): {}
{
    ClosureParameterName() (TypeAnnotation())?
    | ClosureParameterName() TypeAnnotation() <THREE_DOTS>
}

//Проверено
void ClosureParameterName(): {}
{
    Identifier()
}

//Проверено
void CaptureList(): {}
{
    <OPEN_SQUARE_BRACKET> CaptureListItems() <CLOSED_SQUARE_BRACKET>
}

//Проверено
void CaptureListItems(): {}
{
    CaptureListItem()
    | CaptureListItem() <COMMA> CaptureListItems()
}

//Проверено
void CaptureListItem(): {}
{
    (CaptureSpecifier())? Expression()
}

//Проверено
void CaptureSpecifier(): {}
{
    // TODO: проверить токены – unowned(safe) vs <UNOWNED> <OPEN_PARENTHESIS> <SAFE> <CLOSED_PARENTHESIS>
    <WEAK>
    | <UNOWNED>
    | <UNOWNED> <OPEN_PARENTHESIS> <SAFE> <CLOSED_PARENTHESIS>
    | <UNOWNED> <OPEN_PARENTHESIS> <UNSAFE> <CLOSED_PARENTHESIS>
}

/* ===================================================================
                        3.11. GRAMMAR OF A IMPLICIT MEMBER EXPRESSION
   =================================================================== */

//Проверено
void ImplicitMemberExpression(): {}
{
    <DOT> Identifier()
}

/* ===================================================================
                        3.12. GRAMMAR OF A PARENTHESIZED EXPRESSION
   =================================================================== */

//Проверено
void ParenthesizedExpression(): {}
{
    <OPEN_PARENTHESIS> Expression() <CLOSED_PARENTHESIS>
}

/* ===================================================================
                        3.13. GRAMMAR OF A TUPLE EXPRESSION
   =================================================================== */

//Проверено
void TupleExpression(): {}
{
    <OPEN_PARENTHESIS> <CLOSED_PARENTHESIS>
    | <OPEN_PARENTHESIS> TupleElement() <COMMA> TupleElementList() <CLOSED_PARENTHESIS>

}

//Проверено
void TupleElementList(): {}
{
    TupleElement()
    | TupleElement() <COMMA> TupleTypeElementList()
}

//Проверено
void TupleElement(): {}
{
    Expression()
    | Identifier() <COLON> Expression()
}

/* ===================================================================
                        3.14. GRAMMAR OF A WILDCARD EXPRESSION
   =================================================================== */

//Проверено
void WildcardExpression(): {}
{
    <UNDERSCORE>
}

/* ===================================================================
                        3.15. GRAMMAR OF A SELECTOR EXPRESSION
   =================================================================== */

//ToDo проверить токены getter: vs <GETTER> <COLON>
void SelectorExpression(): {}
{
    <SELECTOR> <OPEN_PARENTHESIS> Expression() <CLOSED_PARENTHESIS>
    | <SELECTOR> <OPEN_PARENTHESIS> <GETTER> <COLON> Expression() <CLOSED_PARENTHESIS>
    | <SELECTOR> <OPEN_PARENTHESIS> <SETTER> <COLON> Expression() <CLOSED_PARENTHESIS>

}

/* ===================================================================
                        3.16. GRAMMAR OF A KEY-PATH EXPRESSION
   =================================================================== */

//Проверено
void KeyPathExpression(): {}
{
    <KEY_PATH> <OPEN_PARENTHESIS> Expression() <CLOSED_PARENTHESIS>
}

/* ===================================================================
                        3.17. GRAMMAR OF A POSTFIX EXPRESSION (DONE)
   =================================================================== */

//ToDo проверить postfix-expression → postfix-expression­postfix-operator
//ToDo проверить DynamicTypeExpression()
void PostfixExpression(): {}
{
    (   PrimaryExpression()
        | DynamicTypeExpression()
    )
    (SimplePostfixExpression())?
}

//ToDo проверить рекурсию
void SimplePostfixExpression(): {}
{
     (   FunctionCallExpression()
        | InitializerExpression()
        | ExplicitMemberExpression()
        | PostfixSelfExpression()
        | SubscriptExpression()
        | ForcedValueExpression()
        | OptionalChainingExpression()
    ) (SimplePostfixExpression())?
}

/* ===================================================================
                        3.18. GRAMMAR OF A FUNCTIONAL CALL EXPRESSION (DONE)
   =================================================================== */

void FunctionCallExpression(): {}
{
    FunctionCallArgumentClause()
    | (FunctionCallArgumentClause())? TrailingClosure()
}

//Проверено
void FunctionCallArgumentClause(): {}
{
    <OPEN_PARENTHESIS> <CLOSED_PARENTHESIS>
    | <OPEN_PARENTHESIS> FunctionCallArgumentList() <CLOSED_PARENTHESIS>
}

//Проверено
void FunctionCallArgumentList(): {}
{
    FunctionCallArgument()
    | FunctionCallArgument() <COMMA> FunctionCallArgumentList()
}

//Проверено
void FunctionCallArgument(): {}
{
    Expression()
    | Identifier() <COLON> Expression()
    | Operator()
    | Identifier() <COLON> Operator()
}

//Проверено
void TrailingClosure(): {}
{
    ClosureExpression()
}

/* ===================================================================
                        3.19. GRAMMAR OF AN INITIALIZER EXPRESSION
   =================================================================== */
/*ToDo правило: postfix-expression . init
Проверить разрешение рекурсии, потому что сейчас просто .init пройдёт */
void InitializerExpression(): {}
{
    <DOT> <INIT>
    | <DOT> <INIT> <OPEN_PARENTHESIS> ArgumentNames() <CLOSED_PARENTHESIS>
}

/* ===================================================================
                        3.20. GRAMMAR OF AN EXPLICIT MEMBER EXPRESSION
   =================================================================== */

/*ToDo правило: postfix-expression . decimal-digits
Проверить разрешение рекурсии, потому что сейчас просто .decimal-digits пройдёт */
void ExplicitMemberExpression(): {}
{
    <DOT> DecimalDigits()
    | <DOT> Identifier() (GenericArgumentClause())?
    | <DOT> Identifier() <OPEN_PARENTHESIS> ArgumentNames() <CLOSED_PARENTHESIS>
}

//Проверено
void ArgumentNames(): {}
{
    ArgumentName() (ArgumentNames())?
}

//Проверено
void ArgumentName(): {}
{
    Identifier() <COLON>
}

/* ===================================================================
                        3.21. GRAMMAR OF A SELF EXPRESSION (DONE)
   =================================================================== */

/*ToDo правило: postfix-expression . self
Проверить разрешение рекурсии, потому что сейчас просто .self */
void PostfixSelfExpression(): {}
{
    <DOT> <SELF>
}

/* ===================================================================
                        3.22. GRAMMAR OF A DYNAMIC TYPE EXPRESSION (DONE)
   =================================================================== */

//ToDo что это?
void DynamicTypeExpression(): {}
{
    <TYPE> <OPEN_PARENTHESIS> <OF> <COLON> Expression() <CLOSED_PARENTHESIS>
}

/* ===================================================================
                        3.23. GRAMMAR OF A SUBSCRIPT EXPRESSION
   =================================================================== */

/*ToDo правило: postfix-expression [ expression-list ]
Проверить разрешение рекурсии, потому что сейчас просто [expression-list] пройдёт */
void SubscriptExpression(): {}
{
     <OPEN_SQUARE_BRACKET> ExpressionList() <CLOSED_SQUARE_BRACKET>
}

/* ===================================================================
                        3.24. GRAMMAR OF A FORCED-VALUE EXPRESSION
   =================================================================== */

/*ToDo правило: postfix-expression !
Проверить разрешение рекурсии, потому что сейчас просто ! пройдёт */
void ForcedValueExpression(): {}
{
    <EXCLAMATION_MARK>
}

/* ===================================================================
                        3.25. GRAMMAR OF AN OPTIONAL-CHAINING EXPRESSION
   =================================================================== */

/*ToDo правило: postfix-expression ?
Проверить разрешение рекурсии, потому что сейчас просто ? пройдёт */
void OptionalChainingExpression(): {}
{
    <QUESTION_MARK>
}


/* =====================================================================================================================
                        4. Statements
   ================================================================================================================== */


/* ===================================================================
                        4.1. GRAMMAR OF A STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void Statement(): {}
{
    Expression() (<SEMICOLON>)?
    | Declaration() (<SEMICOLON>)?
    | LoopStatement() (<SEMICOLON>)?
    | BranchStatement() (<SEMICOLON>)?
    | LabeledStatement() (<SEMICOLON>)?
    | ControlTransferStatement() (<SEMICOLON>)?
    | DeferStatement() (<SEMICOLON>)?
    | DoStatement() (<SEMICOLON>)?
    | CompilerControlStatement() (<SEMICOLON>)?
}

// ПРОВЕРЕНО
void Statements(): {}
{
    Statement() (Statements())?
}


/* ===================================================================
                        4.2. GRAMMAR OF A LOOP STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void LoopStatement(): {}
{
    ForInStatement()
    | WhileStatement()
    | RepeatWhileStatement()
}


/* ===================================================================
                        4.3. GRAMMAR OF A FOR-IN STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void ForInStatement(): {}
{
    <FOR> (<CASE>)? Pattern() <IN> Expression() (WhereClause())? CodeBlock()
}


/* ===================================================================
                        4.4. GRAMMAR OF A WHILE STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void WhileStatement(): {}
{
    <WHILE> ConditionList() CodeBlock()
}

// ПРОВЕРЕНО
void ConditionList(): {}
{
    Condition()
    | Condition() <COMMA> ConditionList()
}

// ПРОВЕРЕНО
void Condition(): {}
{
    Expression()
    | AvailabilityCondition()
    | CaseCondition()
    | OptionalBridgingCondition()
}

// ПРОВЕРЕНО
void CaseCondition(): {}
{
    <CASE> Pattern() Initializer()
}

// ПРОВЕРЕНО
void OptionalBridgingCondition(): {}
{
    <LET> Pattern() Initializer()
    | <VAR> Pattern() Initializer()
}


/* ===================================================================
                        4.5. GRAMMAR OF A REPEAT-WHILE STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void RepeatWhileStatement(): {}
{
    <REPEAT> CodeBlock() <WHILE> Expression()
}


/* ===================================================================
                        4.6. GRAMMAR OF A BRANCH STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void BranchStatement(): {}
{
    IfStatement()
    | GuardStatement()
    | SwitchStatement()
}


/* ===================================================================
                        4.7. GRAMMAR OF AN IF STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void IfStatement(): {}
{
    <IF> ConditionList() CodeBlock() (ElseClause())?
}

// ПРОВЕРЕНО
void ElseClause(): {}
{
    <ELSE> CodeBlock()
    | <ELSE> IfStatement()
}


/* ===================================================================
                        4.8. GRAMMAR OF A GUARD STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void GuardStatement(): {}
{
    <GUARD> ConditionList() <ELSE> CodeBlock()
}


/* ===================================================================
                        4.9. GRAMMAR OF A SWITCH STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void SwitchStatement(): {}
{
    <SWITCH> Expression() <OPEN_BRACKET> (SwitchCases())? <CLOSED_BRACKET>
}

// ПРОВЕРЕНО
void SwitchCases(): {}
{
    SwitchCase() (SwitchCases())?
}

// ПРОВЕРЕНО
void SwitchCase(): {}
{
    CaseLabel() Statements()
    | DefaultLabel() Statements()
}

// ПРОВЕРЕНО
void CaseLabel(): {}
{
    <CASE> CaseItemList() <COLON>
}

// ПРОВЕРЕНО
void CaseItemList(): {}
{
    Pattern() (WhereClause())?
    | Pattern() (WhereClause())? <COMMA> CaseItemList()
}

// ПРОВЕРЕНО
void DefaultLabel(): {}
{
    <DEFAULT_1> <COLON>
}

// ПРОВЕРЕНО
void WhereClause(): {}
{
    <WHERE> WhereExpression()
}

// ПРОВЕРЕНО
void WhereExpression(): {}
{
    Expression()
}


/* ===================================================================
                        4.10. GRAMMAR OF A LABELED STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void LabeledStatement(): {}
{
    StatementLabel() LoopStatement()
    | StatementLabel() IfStatement()
    | StatementLabel() SwitchStatement()
    | StatementLabel() DoStatement()
}

// ПРОВЕРЕНО
void StatementLabel(): {}
{
    LabelName() <COLON>
}

// ПРОВЕРЕНО
void LabelName(): {}
{
    Identifier()
}


/* ===================================================================
                        4.11. GRAMMAR OF A CONTROL TRANSFER STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void ControlTransferStatement(): {}
{
    BreakStatement()
    | ContinueStatement()
    | FallthroughStatement()
    | ReturnStatement()
    | ThrowStatement()
}


/* ===================================================================
                        4.12. GRAMMAR OF A BREAK STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void BreakStatement(): {}
{
    <BREAK> (LabelName())?
}


/* ===================================================================
                        4.13. GRAMMAR OF A CONTINUE STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void ContinueStatement(): {}
{
    <CONTINUE> (LabelName())?
}


/* ===================================================================
                        4.14. GRAMMAR OF A FALLTHROUGH STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void FallthroughStatement(): {}
{
    <FALLTHROUGH>
}


/* ===================================================================
                        4.15. GRAMMAR OF A RETURN STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void ReturnStatement(): {}
{
    <RETURN> (Expression())?
}


/* ===================================================================
                        4.16. GRAMMAR OF A THROW STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void ThrowStatement(): {}
{
    <THROW> Expression()
}


/* ===================================================================
                        4.17. GRAMMAR OF A DEFER STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void DeferStatement(): {}
{
    <DEFER> CodeBlock()
}


/* ===================================================================
                        4.18. GRAMMAR OF A DO STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void DoStatement(): {}
{
    <DO> CodeBlock() (CatchClauses())?
}

// ПРОВЕРЕНО
void CatchClauses(): {}
{
    CatchClause() (CatchClauses())?
}

// ПРОВЕРЕНО
void CatchClause(): {}
{
    <CATCH> (Pattern())? (WhereClause())? CodeBlock()
}


/* ===================================================================
                        4.19. GRAMMAR OF A COMPILER CONTROL STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void CompilerControlStatement(): {}
{
    ConditionalCompilationBlock()
    | LineControlStatement()
}


/* ===================================================================
                        4.20. GRAMMAR OF A CONDITIONAL COMPILATION BLOCK (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void ConditionalCompilationBlock(): {}
{
    IfDirectiveClause() (ElseifDirectiveClauses())? (ElseDirectiveClause())? EndifDirective()
}

// ПРОВЕРЕНО
void IfDirectiveClause(): {}
{
    IfDirective() CompilationCondition() (Statements())?
}

// ПРОВЕРЕНО
void ElseifDirectiveClauses(): {}
{
    ElseifDirectiveClause() (ElseifDirectiveClauses())?
}

// ПРОВЕРЕНО
void ElseifDirectiveClause(): {}
{
    ElseifDirective() CompilationCondition() (Statements())?
}

// ПРОВЕРЕНО
void ElseDirectiveClause(): {}
{
    ElseDirective() (Statements())?
}

// ПРОВЕРЕНО
void IfDirective(): {}
{
    <SHARP_IF>
}

// ПРОВЕРЕНО
void ElseifDirective(): {}
{
    <SHARP_ELSEIF>
}

// ПРОВЕРЕНО
void ElseDirective(): {}
{
    <SHARP_ELSE>
}

// ПРОВЕРЕНО
void EndifDirective(): {}
{
    <SHARP_ENDIF>
}

// ПРОВЕРЕНО
void CompilationCondition(): {}
{
    (   PlatformCondition()
        | Identifier()
        | BooleanLiteral()
        | <OPEN_PARENTHESIS> CompilationCondition() <CLOSED_PARENTHESIS>
        | <EXCLAMATION_MARK> CompilationCondition()
    ) (SimpleCompilationCondition())?
}

// TODO: Проверить еще раз
void SimpleCompilationCondition(): {}
{
    (   <DBL_AMPERSAND> CompilationCondition()
        | <DBL_OR> CompilationCondition()
    ) (SimpleCompilationCondition())?
}

// ПРОВЕРЕНО
void PlatformCondition(): {}
{
    <OS> <OPEN_PARENTHESIS> OperatingSystem() <CLOSED_PARENTHESIS>
    | <ARCH> <OPEN_PARENTHESIS> Architecture() <CLOSED_PARENTHESIS>
    | <SWIFT> <OPEN_PARENTHESIS> <MORE_OR_EQUALS> SwiftVersion() <CLOSED_PARENTHESIS>
}

// ПРОВЕРЕНО
void OperatingSystem(): {}
{
    <MAC_OS>
    | <IOS>
    | <WATCH_OS>
    | <TV_OS>
}

// ПРОВЕРЕНО
void Architecture(): {}
{
    <I_386>
    | <X_86_64>
    | <ARM>
    | <ARM_64>
}

// ПРОВЕРЕНО
void SwiftVersion(): {}
{
    DecimalDigits() (SwiftVersionConfiguration())?
}

// ПРОВЕРЕНО
void SwiftVersionConfiguration(): {}
{
    <DOT> DecimalDigits() (SwiftVersionConfiguration())?
}


/* ===================================================================
                        4.21. GRAMMAR OF A LINE CONTROL STATEMENT (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void LineControlStatement(): {}
{
    <SOURCE_LOCATION> <OPEN_PARENTHESIS> <FILE> FileName() <COMMA> <LINE> LineNumber() <CLOSED_PARENTHESIS>
    | <SOURCE_LOCATION> <OPEN_PARENTHESIS> <CLOSED_PARENTHESIS>
}

// ПРОВЕРЕНО
void LineNumber(): {}
{
    DecimalDigits()
}

// ПРОВЕРЕНО
void FileName(): {}
{
    StaticStringLiteral()
}


/* ===================================================================
                        4.22. GRAMMAR OF AN AVAILABILITY CONDITION (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void AvailabilityCondition(): {}
{
    <SHARP_AVAILABLE> <OPEN_PARENTHESIS> AvailabilityArguments() <CLOSED_PARENTHESIS>
}

// ПРОВЕРЕНО
void AvailabilityArguments(): {}
{
    AvailabilityArgument()
    | AvailabilityArgument() <COMMA> AvailabilityArguments()
}

// ПРОВЕРЕНО
void AvailabilityArgument(): {}
{
    PlatformName() PlatformVersion()
    | <STAR>
}

// ПРОВЕРЕНО
void PlatformName(): {}
{
    <IOS>
    | <IOS_APP_EXT>
    | <MAC_OS>
    | <MAC_OS_APP_EXT>
    | <WATCH_OS>
    | <TV_OS>
}

// ПРОВЕРЕНО
void PlatformVersion(): {}
{
    DecimalDigits()
    | DecimalDigits() <DOT> DecimalDigits()
    | DecimalDigits() <DOT> DecimalDigits() <DOT> DecimalDigits()
}



/* =====================================================================================================================
                        5. Declarations
   ================================================================================================================== */


/* ===================================================================
                        5.1. GRAMMAR OF A DECLARATION
   =================================================================== */

//Проверено
void Declaration(): {}
{
    ImportDeclaration()
    | ConstantDeclaration()
    | VariableDeclaration()
    | TypealiasDeclaration()
    | FunctionDeclaration()
    | EnumDeclaration()
    | StructDeclaration()
    | ClassDeclaration()
    | ProtocolDeclaration()
    | InitializerDeclaration()
    | DeinitializerDeclaration()
    | ExtensionDeclaration()
    | SubscriptDeclaration()
    | OperatorDeclaration()
    | PrecedenceGroupDeclaration()
}

//Проверено
void Declarations(): {}
{
    Declaration() (Declarations())?
}

/* ===================================================================
                        5.2. GRAMMAR OF A TOP-LEVEL DECLARATION
   =================================================================== */

//Проверено
void TopLevelDeclaration(): {}
{
    (Statements())?
}

/* ===================================================================
                        5.3. GRAMMAR OF A CODE BLOCK
   =================================================================== */

//Проверено
void CodeBlock(): {}
{
    <OPEN_BRACKET> (Statements())? <CLOSED_BRACKET>
}

/* ===================================================================
                        5.4. GRAMMAR OF AN IMPORT DECLARATION
   =================================================================== */

//Проверено
void ImportDeclaration(): {}
{
    (Attributes())? <IMPORT> (ImportKind())? ImportPath()
}

//Проверено
void ImportKind(): {}
{
    <TYPE_ALIAS>
    | <STRUCT>
    | <CLASS>
    | <ENUM>
    | <PROTOCOL>
    | <VAR>
    | <FUNC>
}

//Проверено
void ImportPath(): {}
{
    ImportPathIdentifier()
    | ImportPathIdentifier() <DOT> ImportPath()
}

//Проверено
void ImportPathIdentifier(): {}
{
    Identifier()
    | Operator()
}


/* ===================================================================
                        5.5. GRAMMAR OF A CONSTANT DECLARATION
   =================================================================== */

//Проверено
void ConstantDeclaration(): {}
{
    (Attributes())? (DeclarationModifiers())? <LET> PatternInitializerList()
}

//Проверено
void PatternInitializerList(): {}
{
    PatternInitializer()
    | PatternInitializer() <COMMA> PatternInitializerList()
}

//Проверено
void PatternInitializer(): {}
{
    Pattern() (Initializer())?
}

//Проверено
void Initializer(): {}
{
    <ASSIGN> Expression()
}


/* ===================================================================
                        5.6. GRAMMAR OF A VARIABLE DECLARATION
   =================================================================== */

//Проверено
void VariableDeclaration(): {}
{
    VariableDeclarationHead() PatternInitializerList()
    | VariableDeclarationHead() VariableName() TypeAnnotation() CodeBlock()
    | VariableDeclarationHead() VariableName() TypeAnnotation() GetterSetterBlock()
    | VariableDeclarationHead() VariableName() TypeAnnotation() GetterSetterKeywordBlock()
    | VariableDeclarationHead() VariableName() Initializer() WillSetDidSetBlock()
    | VariableDeclarationHead() VariableName() TypeAnnotation() (Initializer())? WillSetDidSetBlock()
}


//Проверено
void VariableDeclarationHead(): {}
{
    (Attributes())? (DeclarationModifiers())? <VAR>
}

//Проверено
void VariableName(): {}
{
    Identifier()
}


//Проверено
void GetterSetterBlock(): {}
{
    CodeBlock()
    | <OPEN_BRACKET> GetterClause() (SetterClause())? <CLOSED_BRACKET>
    | <OPEN_BRACKET> SetterClause() GetterClause() <CLOSED_BRACKET>
}

//Проверено
void GetterClause(): {}
{
    (Attributes())? (MutationModifier())? <GET> CodeBlock()
}

//Проверено
void SetterClause(): {}
{
   (Attributes())? (MutationModifier())? <SET> (SetterName())? CodeBlock()
}

//Проверено
void SetterName(): {}
{
    <OPEN_PARENTHESIS> Identifier() <CLOSED_PARENTHESIS>
}


//Проверено
void GetterSetterKeywordBlock(): {}
{
    <OPEN_BRACKET> GetterKeywordClause() (SetterKeywordClause())? <CLOSED_BRACKET>
    | <OPEN_BRACKET> SetterKeywordClause() GetterKeywordClause() <CLOSED_BRACKET>
}

//Проверено
void GetterKeywordClause(): {}
{
    (Attributes())? (MutationModifier())? <GET>
}

//Проверено
void SetterKeywordClause(): {}
{
   (Attributes())? (MutationModifier())? <SET>
}


//Проверено
void WillSetDidSetBlock(): {}
{
    <OPEN_BRACKET> WillSetClause() (DidSetClause())? <CLOSED_BRACKET>
    | <OPEN_BRACKET> DidSetClause() (WillSetClause())? <CLOSED_BRACKET>
}

//Проверено
void WillSetClause(): {}
{
    (Attributes())? <WILL_SET> (SetterName())? CodeBlock()
}

//Проверено
void DidSetClause(): {}
{
   (Attributes())? <DID_SET> (SetterName())? CodeBlock()
}



/* ===================================================================
                        5.7. GRAMMAR OF A TYPE ALIAS DECLARATION
   =================================================================== */

//Проверено
void TypealiasDeclaration(): {}
{
    (Attributes())? (AccessLevelModifier())? <TYPE_ALIAS> TypealiasName() (GenericParameterClause())? TypealiasAssignment()
}

//Проверено
void TypealiasName(): {}
{
    Identifier()
}

//Проверено
void TypealiasAssignment(): {}
{
    <ASSIGN> Type()
}


/* ===================================================================
                        5.8. GRAMMAR OF A FUNCTION DECLARATION
   =================================================================== */

//Проверено
void FunctionDeclaration(): {}
{
    FunctionHead() FunctionName() (GenericParameterClause())? FunctionSignature() (GenericWhereClause())? (FunctionBody())?
}


//Проверено
void FunctionHead(): {}
{
    (Attributes())? (DeclarationModifiers())? <FUNC>
}

//Проверено
void FunctionName(): {}
{
    Identifier()
    | Operator()
}


//Проверено
void FunctionSignature(): {}
{
    ParameterClause() ((<THROWS>)? | <RETHROWS>) (FunctionResult())?
}

//Проверено
void FunctionResult(): {}
{
    <ARROW_RIGHT> (Attributes())? Type()
}

//Проверено
void FunctionBody(): {}
{
    CodeBlock()
}


//Проверено
void ParameterClause(): {}
{
    <OPEN_PARENTHESIS> (ParameterList())? <CLOSED_PARENTHESIS>
}

//Проверено
void ParameterList(): {}
{
    Parameter()
    | Parameter() <COMMA> ParameterList()
}

//Проверено
void Parameter(): {}
{
    (ExternalParameterName())? LocalParameterName() TypeAnnotation() (DefaultArgumentClause())?
    | (ExternalParameterName())? LocalParameterName() TypeAnnotation()
    | (ExternalParameterName())? LocalParameterName() TypeAnnotation() <THREE_DOTS>
}

//Проверено
void ExternalParameterName(): {}
{
    Identifier()
}


//Проверено
void LocalParameterName(): {}
{
    Identifier()
}

//Проверено
void DefaultArgumentClause(): {}
{
    <ASSIGN> Expression()
}


/* ===================================================================
                        5.9. GRAMMAR OF AN ENUMERATION DECLARATION
   =================================================================== */

//Проверено
void EnumDeclaration(): {}
{
    (Attributes())? (AccessLevelModifier())? UnionStyleEnum()
    | (Attributes())? (AccessLevelModifier())? RawValueStyleEnum()
}


//Проверено
void UnionStyleEnum(): {}
{
    (<INDIRECT>)? <ENUM> EnumName() (GenericParameterClause())? (TypeInheritanceClause())? (GenericWhereClause())? <OPEN_BRACKET> (UnionStyleEnumMembers())? <CLOSED_BRACKET>
}

//Проверено
void UnionStyleEnumMembers(): {}
{
    UnionStyleEnumMember() (UnionStyleEnumMembers())?
}

//Проверено
void UnionStyleEnumMember(): {}
{
    Declaration()
    | UnionStyleEnumCaseClause()
    | CompilerControlStatement()
}

//Проверено
void UnionStyleEnumCaseClause(): {}
{
    (Attributes())? (<INDIRECT>)? <CASE> UnionStyleEnumCaseList()
}

//Проверено
void UnionStyleEnumCaseList(): {}
{
    UnionStyleEnumCase()
    | UnionStyleEnumCase() <COMMA> UnionStyleEnumCaseList()
}

//Проверено
void UnionStyleEnumCase(): {}
{
    EnumCaseName() (TupleType())?
}

//Проверено
void EnumName(): {}
{
    Identifier()
}

//Проверено
void EnumCaseName(): {}
{
    Identifier()
}


//Проверено
void RawValueStyleEnum(): {}
{
    <ENUM> EnumName() (GenericParameterClause())? TypeInheritanceClause() (GenericWhereClause())? <OPEN_BRACKET> RawValueStyleEnumMembers() <CLOSED_BRACKET>
}

//Проверено
void RawValueStyleEnumMembers(): {}
{
    RawValueStyleEnumMember() (RawValueStyleEnumMembers())?
}

//Проверено
void RawValueStyleEnumMember(): {}
{
    Declaration()
    | RawValueStyleEnumCaseClause()
    | CompilerControlStatement()
}

//Проверено
void RawValueStyleEnumCaseClause(): {}
{
    (Attributes())? <CASE> RawValueStyleEnumCaseList()
}

//Проверено
void RawValueStyleEnumCaseList(): {}
{
    RawValueStyleEnumCase()
    | RawValueStyleEnumCase() <COMMA> RawValueStyleEnumCaseList()
}

//Проверено
void RawValueStyleEnumCase(): {}
{
    EnumCaseName() (RawValueAssignment())?
}

//Проверено
void RawValueAssignment(): {}
{
    <ASSIGN> RawValueLiteral()
}

//Проверено
void RawValueLiteral(): {}
{
    NumericLiteral()
    | StaticStringLiteral()
    | BooleanLiteral()
}


/* ===================================================================
                        5.10. GRAMMAR OF A STRUCTURE DECLARATION
   =================================================================== */

//Проверено
void StructDeclaration(): {}
{
    (Attributes())? (AccessLevelModifier())? <STRUCT> StructName() (GenericParameterClause())? (TypeInheritanceClause())? (GenericWhereClause())? StructBody()
}

//Проверено
void StructName(): {}
{
    Identifier()
}

//Проверено
void StructBody(): {}
{
    <OPEN_BRACKET> (StructMembers())? <CLOSED_BRACKET>
}


//Проверено
void StructMembers(): {}
{
    StructMember() (StructMembers())?
}

//Проверено
void StructMember(): {}
{
    Declaration()
    | CompilerControlStatement()
}


/* ===================================================================
                        5.11. GRAMMAR OF A CLASS DECLARATION
   =================================================================== */

//Проверено
void ClassDeclaration(): {}
{
    (Attributes())? (AccessLevelModifier())? (<FINAL>)? <CLASS> ClassName() (GenericParameterClause())? (TypeInheritanceClause())? (GenericWhereClause())? ClassBody()
    | (Attributes())? <FINAL> (AccessLevelModifier())? <CLASS> ClassName() (GenericParameterClause())? (TypeInheritanceClause())? (GenericWhereClause())? ClassBody()
}

//Проверено
void ClassName(): {}
{
    Identifier()
}

//Проверено
void ClassBody(): {}
{
    <OPEN_BRACKET> (ClassMembers())? <CLOSED_BRACKET>
}


//Проверено
void ClassMembers(): {}
{
    ClassMember() (ClassMembers())?
}

//Проверено
void ClassMember(): {}
{
    Declaration()
    | CompilerControlStatement()
}


/* ===================================================================
                        5.12. GRAMMAR OF A PROTOCOL DECLARATION
   =================================================================== */

//Проверено
void ProtocolDeclaration(): {}
{
    (Attributes())? (AccessLevelModifier())? <PROTOCOL> ProtocolName() (TypeInheritanceClause())? ProtocolBody()
}

//Проверено
void ProtocolName(): {}
{
    Identifier()
}

//Проверено
void ProtocolBody(): {}
{
    <OPEN_BRACKET> (ProtocolMembers())? <CLOSED_BRACKET>
}


//Проверено
void ProtocolMembers(): {}
{
    ProtocolMember() (ProtocolMembers())?
}

//Проверено
void ProtocolMember(): {}
{
    ProtocolMemberDeclaration()
    | CompilerControlStatement()
}


//Проверено
void ProtocolMemberDeclaration(): {}
{
    ProtocolPropertyDeclaration()
    | ProtocolMethodDeclaration()
    | ProtocolInitializerDeclaration()
    | ProtocolSubscriptDeclaration()
    | ProtocolAssociatedTypeDeclaration()
    | TypealiasDeclaration()
}


/* ===================================================================
                        5.13. GRAMMAR OF A PROTOCOL PROPERTY DECLARATION
   =================================================================== */

//Проверено
void ProtocolPropertyDeclaration(): {}
{
    VariableDeclarationHead() VariableName() TypeAnnotation() GetterSetterKeywordBlock()
}


/* ===================================================================
                        5.14. GRAMMAR OF A PROTOCOL METHOD DECLARATION
   =================================================================== */

//Проверено
void ProtocolMethodDeclaration(): {}
{
    FunctionHead() FunctionName() (GenericParameterClause())? FunctionSignature() (GenericWhereClause())?
}


/* ===================================================================
                        5.15. GRAMMAR OF A PROTOCOL INITIALIZER DECLARATION
   =================================================================== */

//Проверено
void ProtocolInitializerDeclaration(): {}
{
    InitializerHead() (GenericParameterClause())? ParameterClause() (<THROWS>)? (GenericWhereClause())?
    | InitializerHead() (GenericParameterClause())? ParameterClause() <RETHROWS> (GenericWhereClause())?
}


/* ===================================================================
                        5.16. GRAMMAR OF A PROTOCOL SUBSCRIPT DECLARATION
   =================================================================== */

//Проверено
void ProtocolSubscriptDeclaration(): {}
{
    SubscriptHead() SubscriptResult() GetterSetterKeywordBlock()
}


/* ===================================================================
                        5.17. GRAMMAR OF A PROTOCOL ASSOCIATED DECLARATION
   =================================================================== */

//Проверено
void ProtocolAssociatedTypeDeclaration(): {}
{
    (Attributes())? (AccessLevelModifier())? <ASSOCIATED_TYPE> TypealiasName() (TypeInheritanceClause())? (TypealiasAssignment())?
}


/* ===================================================================
                        5.18. GRAMMAR OF AN INITIALIZER DECLARATION
   =================================================================== */

//Проверено
void InitializerDeclaration(): {}
{
    InitializerHead() (GenericParameterClause())? ParameterClause() (<THROWS>)? (GenericWhereClause())? InitializerBody()
    | InitializerHead() (GenericParameterClause())? ParameterClause() <RETHROWS> (GenericWhereClause())? InitializerBody()
}

//Проверено
void InitializerHead(): {}
{
    (Attributes())? (DeclarationModifiers())? <INIT>
    | (Attributes())? (DeclarationModifiers())? <INIT> <QUESTION_MARK>
    | (Attributes())? (DeclarationModifiers())? <INIT> <EXCLAMATION_MARK>
}

//Проверено
void InitializerBody(): {}
{
    CodeBlock()
}


/* ===================================================================
                        5.19. GRAMMAR OF A DEINITIALIZER DECLARATION
   =================================================================== */

//Проверено
void DeinitializerDeclaration(): {}
{
    (Attributes())? <DEINIT> CodeBlock()
}


/* ===================================================================
                        5.20. GRAMMAR OF AN EXTENSION DECLARATION
   =================================================================== */

//Проверено
void ExtensionDeclaration(): {}
{
    (Attributes())? (AccessLevelModifier())? <EXTENSION> TypeIdentifier() (TypeInheritanceClause())? ExtensionBody()
    | (Attributes())? (AccessLevelModifier())? <EXTENSION> TypeIdentifier() GenericWhereClause() ExtensionBody()
}

//Проверено
void ExtensionBody(): {}
{
    <OPEN_BRACKET> (ExtensionMembers())? <CLOSED_BRACKET>
}


//Проверено
void ExtensionMembers(): {}
{
    ExtensionMember() (ExtensionMembers())?
}

//Проверено
void ExtensionMember(): {}
{
    Declaration()
    | CompilerControlStatement()
}



/* ===================================================================
                        5.21. GRAMMAR OF A SUBSCRIPT DECLARATION
   =================================================================== */

//Проверено
void SubscriptDeclaration(): {}
{
    SubscriptHead() SubscriptResult() CodeBlock()
    | SubscriptHead() SubscriptResult() GetterSetterBlock()
    | SubscriptHead() SubscriptResult() GetterSetterKeywordBlock()
}

//Проверено
void SubscriptHead(): {}
{
    (Attributes())? (DeclarationModifiers())? <SUBSCRIPT> ParameterClause()
}

//Проверено
void SubscriptResult(): {}
{
    <ARROW_RIGHT> (Attributes())? Type()
}


/* ===================================================================
                        5.22. GRAMMAR OF AN OPERATOR DECLARATION
   =================================================================== */

//Проверено
void OperatorDeclaration(): {}
{
    PrefixOperatorDeclaration()
    | PostfixOperatorDeclaration()
    | InfixOperatorDeclaration()
}


//Проверено
void PrefixOperatorDeclaration(): {}
{
    <PREFIX> <OPERATOR> Operator()
}

//Проверено
void PostfixOperatorDeclaration(): {}
{
    <POSTFIX> <OPERATOR> Operator()
}

//Проверено
void InfixOperatorDeclaration(): {}
{
    <INFIX> <OPERATOR> Operator() (InfixOperatorGroup())?
}


//Проверено
void InfixOperatorGroup(): {}
{
    PrecedenceGroupName()
}


/* ===================================================================
                        5.23. GRAMMAR OF A PRECEDENCE GROUP DECLARATION
   =================================================================== */

//Проверено
void PrecedenceGroupDeclaration(): {}
{
    <PRECEDENCE_GROUP> PrecedenceGroupName() <OPEN_BRACKET> (PrecedenceGroupAttributes())? <CLOSED_BRACKET>
}


//Проверено
void PrecedenceGroupAttributes(): {}
{
    PrecedenceGroupAttribute() (PrecedenceGroupAttributes())?
}

//Проверено
void PrecedenceGroupAttribute(): {}
{
    PrecedenceGroupRelation()
    | PrecedenceGroupAssignment()
    | PrecedenceGroupAssociativity()
}

//Проверено
void PrecedenceGroupRelation(): {}
{
    <HIGHER_THAN> <COLON> PrecedenceGroupNames()
    | <LOWER_THAN> <COLON> PrecedenceGroupNames()
}

//Проверено
void PrecedenceGroupAssignment(): {}
{
    <ASSIGNMENT> <COLON> BooleanLiteral()
}

//Проверено
void PrecedenceGroupAssociativity(): {}
{
    <ASSOCIATIVITY> <COLON> <LEFT>
    | <ASSOCIATIVITY> <COLON> <RIGHT>
    | <ASSOCIATIVITY> <COLON> <NONE>
}


//Проверено
void PrecedenceGroupNames(): {}
{
    PrecedenceGroupName()
    | PrecedenceGroupName() <COMMA> PrecedenceGroupNames()
}

//Проверено
void PrecedenceGroupName(): {}
{
    Identifier()
}


/* ===================================================================
                        5.24. GRAMMAR OF A DECLARATION MODIFIER
   =================================================================== */

//Проверено
void DeclarationModifier(): {}
{
    <CLASS>
    | < CONVENIENCE>
    | <DYNAMIC>
    | <FINAL>
    | <INFIX>
    | <LAZY>
    | <OPTIONAL>
    | <OVERRIDE>
    | <POSTFIX>
    | <PREFIX>
    | <REQUIRED>
    | <STATIC>
    | <UNOWNED>
    | <UNOWNED> <OPEN_PARENTHESIS> <SAFE> <CLOSED_PARENTHESIS>
    | <UNOWNED> <OPEN_PARENTHESIS> <UNSAFE> <CLOSED_PARENTHESIS>
    | <WEAK>
    | AccessLevelModifier()
    | MutationModifier()
}

//Проверено
void DeclarationModifiers(): {}
{
    DeclarationModifier() (DeclarationModifiers())?
}

//Проверено
void AccessLevelModifier(): {}
{
    <PRIVATE>
    | <PRIVATE> <OPEN_PARENTHESIS> <SET> <CLOSED_PARENTHESIS>
    | <FILEPRIVATE>
    | <FILEPRIVATE> <OPEN_PARENTHESIS> <SET> <CLOSED_PARENTHESIS>
    | <INTERNAL>
    | <INTERNAL> <OPEN_PARENTHESIS> <SET> <CLOSED_PARENTHESIS>
    | <PUBLIC>
    | <PUBLIC> <OPEN_PARENTHESIS> <SET> <CLOSED_PARENTHESIS>
    | <OPEN>
    | <OPEN> <OPEN_PARENTHESIS> <SET> <CLOSED_PARENTHESIS>
}

//Проверено
void MutationModifier(): {}
{
    <MUTATING>
    | <NON_MUTATING>
}



/* =====================================================================================================================
                        6. Attributes
   ================================================================================================================== */


/* ===================================================================
                        6.1. GRAMMAR OF AN ATTRIBUTE (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void Attribute(): {}
{
    <AT> AttributeName() (AttributeArgumentClause())?
}

// ПРОВЕРЕНО
void AttributeName(): {}
{
    Identifier()
}

// ПРОВЕРЕНО
void AttributeArgumentClause(): {}
{
    <OPEN_PARENTHESIS> (BalancedTokens())? <CLOSED_PARENTHESIS>
}

// ПРОВЕРЕНО
void Attributes(): {}
{
    Attribute() (Attributes())?
}

// ПРОВЕРЕНО
void BalancedTokens(): {}
{
    BalancedToken() (BalancedTokens())?
}

// TODO: Доделать
void BalancedToken(): {}
{
    <OPEN_PARENTHESIS> (BalancedTokens())? <CLOSED_PARENTHESIS>
    | <OPEN_SQUARE_BRACKET> (BalancedTokens())? <CLOSED_SQUARE_BRACKET>
    | <OPEN_BRACKET> (BalancedTokens())? <CLOSED_BRACKET>
    | Identifier()
    | Operator()
}

/* =====================================================================================================================
                        7. Patterns (DONE)
   ================================================================================================================== */

/* ===================================================================
                        7.1. GRAMMAR OF A PATTERN (DONE)
   =================================================================== */

//Проверено
void Pattern(): {}
{
    (   WildcardPattern() (TypeAnnotation())?
        | IdentifierPattern() (TypeAnnotation())?
        | ValueBindingPattern()
        | TuplePattern() (TypeAnnotation())?
        | EnumCasePattern()
        | OptionalPattern()
        | IsPattern()
        | ExpressionPattern()
    ) (SimplePattern())?
}

//Проверено
void SimplePattern(): {}
{
    AsPattern() (SimplePattern())?
}

/* ===================================================================
                        7.2. GRAMMAR OF A WILDCARD PATTERN (DONE)
   =================================================================== */

//Проверено
void WildcardPattern(): {}
{
    <UNDERSCORE>
}

/* ===================================================================
                        7.3. GRAMMAR OF AN IDENTIFIER PATTERN (DONE)
   =================================================================== */

//Проверено
void IdentifierPattern(): {}
{
    Identifier()
}

/* ===================================================================
                        7.4. GRAMMAR OF A VALUE-BINDING PATTERN (DONE)
   =================================================================== */

//Проверено
void ValueBindingPattern(): {}
{
    <VAR> Pattern()
    | <LET> Pattern()
}

/* ===================================================================
                        7.5 GRAMMAR OF A TUPLE PATTERN (DONE)
   =================================================================== */

//Проверено
void TuplePattern(): {}
{
    <OPEN_PARENTHESIS> (TuplePatternElementList())? <CLOSED_PARENTHESIS>
}

//Проверено
void TuplePatternElementList(): {}
{
    TuplePatternElement()
    | TuplePatternElement() <COMMA> TupleTypeElementList()
}

//Проверено
void TuplePatternElement(): {}
{
    Pattern()
    | Identifier() <COLON> Pattern()
}

/* ===================================================================
                        7.6. GRAMMAR OF AN ENUMERATION CASE PATTERN (DONE)
   =================================================================== */

//Проверено
void EnumCasePattern(): {}
{
    (TypeIdentifier())? <DOT> EnumCaseName() (TuplePattern())?
}

/* ===================================================================
                        7.7. GRAMMAR OF AN OPTIONAL PATTERN (DONE)
   =================================================================== */

//Проверено
void OptionalPattern(): {}
{
    IdentifierPattern() <QUESTION_MARK>
}


/* ===================================================================
                        7.8. GRAMMAR OF A TYPE CASTING PATTERN (DONE)
   =================================================================== */

//Проверено
void TypeCastingPattern(): {}
{
    IsPattern()
    | AsPattern()
}

//Проверено
void IsPattern(): {}
{
    <IS> Type()
}

//Проверено
void AsPattern(): {}
{
    <AS> Type()
}

/* ===================================================================
                        7.9. GRAMMAR OF AN EXPRESSION PATTERN (DONE)
   =================================================================== */

//Проверено
void ExpressionPattern(): {}
{
    Expression()
}


/* =====================================================================================================================
                        8. Generic Parameters and Arguments
   ================================================================================================================== */


/* ===================================================================
                        8.1. GRAMMAR OF A GENERIC PARAMETER CLAUSE (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void GenericParameterClause(): {}
{
    <OPEN_TRIANGULAR_BRACKET> GenericParameterList() <CLOSED_TRIANGULAR_BRACKET>
}

// ПРОВЕРЕНО
void GenericParameterList(): {}
{
    GenericParameter()
    | GenericParameter() <COMMA> GenericParameterList()
}

// ПРОВЕРЕНО
void GenericParameter(): {}
{
    TypeName()
    | TypeName() <COLON> TypeIdentifier()
    | TypeName() <COLON> ProtocolCompositionType()
}

// ПРОВЕРЕНО
void GenericWhereClause(): {}
{
    <WHERE> RequirementList()
}

// ПРОВЕРЕНО
void RequirementList(): {}
{
    Requirement()
    | Requirement() <COMMA> RequirementList()
}

// ПРОВЕРЕНО
void Requirement(): {}
{
    ConformanceRequirement()
    | SameTypeRequirement()
}

// ПРОВЕРЕНО
void ConformanceRequirement(): {}
{
    TypeIdentifier() <COLON> TypeIdentifier()
    | TypeIdentifier() <COLON> ProtocolCompositionType()
}

// ПРОВЕРЕНО
void SameTypeRequirement(): {}
{
    TypeIdentifier() <EQUALS> Type()
}


/* ===================================================================
                        8.2. GRAMMAR OF A GENERIC ARGUMENT CLAUSE (ПРОВЕРЕНО)
   =================================================================== */

// ПРОВЕРЕНО
void GenericArgumentClause(): {}
{
    <OPEN_TRIANGULAR_BRACKET> GenericArgumentList() <CLOSED_TRIANGULAR_BRACKET>
}

// ПРОВЕРЕНО
void GenericArgumentList(): {}
{
    GenericArgument()
    | GenericArgument() <COMMA> GenericArgumentList()
}

// ПРОВЕРЕНО
void GenericArgument(): {}
{
    Type()
}