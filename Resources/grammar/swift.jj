options
{
     LOOKAHEAD=2;
}

PARSER_BEGIN(JavaSwift)

public class JavaSwift
{
    public static void main(String args[]) throws ParseException
    {
        JavaSwift parser = new JavaSwift(System.in);
        while (true)
        {
            parser.parseOneLine();
        }
    }
}

PARSER_END(JavaSwift)

TOKEN:
{

    < UPPER_LETTER: ["A"-"Z"] >
    | < LOWER_LETTER: ["a"-"z"] >
    | < UNDERSCORE: "_" >
    | < EXTENDED_UNICODE: ("U+00A8") | ("U+00AA") | ("U+00AD") | ("U+00AF") | (["U+00B2"-"U+00B5"]) | (["U+00B7"-"U+00BA"]) >
    | < EXTENDED_UNICODE: (["U+00BC"-"U+00BE"]) | (["U+00C0"-"U+00D6"]) | (["U+00D8"-"U+00F6"]) | (["U+00F8"-"U+00FF"]) >
    | < EXTENDED_UNICODE: (["U+0100"-"U+02FF"]) | (["U+0370"-"U+167F"]) | (["U+1681"-"U+180D"]) | (["U+180F"-"U+1DBF"]) >
    | < EXTENDED_UNICODE: (["U+1E00"-"U+1FFF"]) >
    | < EXTENDED_UNICODE: (["U+200B"-"U+200D"]) | (["U+202A"-"U+202E"]) | (["U+203F"-"U+2040"]) | ("U+2054") | (["U+2060"-"U+206F"]) >
    | < EXTENDED_UNICODE: (["U+2070"-"U+20CF"]) | (["U+2100"-"U+218F"]) | (["U+2460"-"U+24FF"]) | (["U+2776"-"U+2793"]) >
    | < EXTENDED_UNICODE: (["U+2C00"-"U+2DFF "]) | (["U+2E80"-"U+2FFF"]) >
    | < EXTENDED_UNICODE: (["U+3004"-"U+3007"]) | (["U+3021"-"U+302F"]) | (["U+3031"-"U+303F"]) | (["U+3040"-"U+D7FF"]) >
    | < EXTENDED_UNICODE: (["U+F900"-"U+FD3D"]) | (["U+FD40"-"U+FDCF"]) | (["U+FDF0"-"U+FE1F"]) | (["U+FE30"-"U+FE44"]) >
    | < EXTENDED_UNICODE: (["U+FE47"-"U+FFFD"]) >
    | < EXTENDED_UNICODE: (["U+10000"-"U+1FFFD"]) | (["U+20000"-"U+2FFFD"]) | (["U+30000"-"U+3FFFD"]) | (["U+40000"-"U+4FFFD"]) >
    | < EXTENDED_UNICODE: (["U+50000"-"U+5FFFD"]) | (["U+60000"-"U+6FFFD"]) | (["U+70000"-"U+7FFFD"]) | (["U+80000"-"U+8FFFD"]) >
    | < EXTENDED_UNICODE: (["U+90000"-"U+9FFFD"]) | (["U+A0000"-"U+AFFFD"]) | (["U+B0000"-"U+BFFFD"]) | (["U+C0000"-"U+CFFFD"]) >
    | < EXTENDED_UNICODE: (["U+D0000"-"U+DFFFD "]) | (["U+E0000"-"U+EFFFD"]) >
    | < EXTENDED_UNICODE: (["U+0300"-"U+036F "]) | (["U+1DC0"-"U+1DFF"]) | (["U+20D0"-"U+20FF"]) | (["U+FE20"-"U+FE2F"]) >

    | < ESCAPE_CHARACTERS: ("\0") | ("\\") | ("\t") | ("\n") | ("\r") | ("\"")  | ("\'") >
    | < ESCAPE_CHARACTERS: ("\\u") (<OPEN_BRACKET>) ("Between one and eight hexadecimal digits") (<CLOSED_BRACKET>) >

    /* ================================
                    Digits
       ================================ */
    | < DIGIT: ["0"-"9"] >

    | < BINARY_DIGIT_BEGIN: "0b" >
    | < BINARY_DIGIT: ["0"-"1"] >

    | < OCTAL_DIGIT_BEGIN: "0o" >
    | < OCTAL_DIGIT: ["0"-"7"] >
    | < DECIMAL_DIGIT: (<DIGIT>)>

    | < HEXADECIMAL_DIGIT_BEGIN: "0x">
    | < HEXADECIMAL_DIGIT: (<DECIMAL_DIGIT>) | (["a"-"f"]) | (["A"-"F"]) >


    /* ================================
                    Math
       ================================ */
    | < PLUS: "+" >
    | < MINUS: "-" >
    | < ASSIGN: "=" >
    | < E: ("E") | ("e") >
    | < P: ("P") | ("p") >
    | <STAR: "*" >
    | <PERCENT: "%" >
    | <MORE_OR_EQUALS: ">=" >
    | <LESS_OR_EQUALS: "<=" >
    | <EQUALS: "==" >

    /* ================================
                    Literals
       ================================ */
    | < TRUE: "true">
    | < FALSE: "false">
    | < NIL: "nil">
    | < SHARP_FILE: "#file" >
    | < SHARP_LINE: "#line" >
    | < COLUMN: "#column" >
    | < FUNCTION: "#function" >
    | < COLOR_LITERAL: "#colorLiteral" >
    | < RED: "red" >
    | < GREEN: "green" >
    | < BLUE: "blue" >
    | < ALPHA: "alpha" >
    | < FILE_LITERAL: "#fileLiteral" >
    | < IMAGE_LITERAL: "#imageLiteral" >
    | < RESOURCE_NAME: "resourceName" >


    /* ================================
                    Operators
       ================================ */
    | < OPERATOR_HEAD: (["U+00A1"-"U+00A7"]) >
    | < OPERATOR_HEAD: ("U+00A9") | ("U+00AB") >
    | < OPERATOR_HEAD: ("U+00AC ") | ("U+00AE") >
    | < OPERATOR_HEAD: (["U+00B0"-"U+00B1"]) | ("U+00B6 ") | ("U+00BB") | ("U+00BF ") | ("U+00D7") | ("U+00F7") >
    | < OPERATOR_HEAD: (["U+2016"-"U+2017 "]) | (["U+2020"-"U+2027 "]) >
    | < OPERATOR_HEAD: (["U+2030"-"U+203E"]) >
    | < OPERATOR_HEAD: (["U+2041"-"U+2053"]) >
    | < OPERATOR_HEAD: (["U+2055"-"U+205E"]) >
    | < OPERATOR_HEAD: (["U+2190"-"U+23FF"]) >
    | < OPERATOR_HEAD: (["U+2500"-"U+2775"]) >
    | < OPERATOR_HEAD: (["U+2794"-"U+2BFF"]) >
    | < OPERATOR_HEAD: (["U+2E00"-"U+2E7F"]) >
    | < OPERATOR_HEAD: (["U+3001"-"U+3003"]) >
    | < OPERATOR_HEAD: (["U+3008"-"U+3030"]) >

    | < OPERATOR_CHARACTER: (["U+0300"-"U+036F"]) >
    | < OPERATOR_CHARACTER: (["U+1DC0"-"U+1DFF"]) >
    | < OPERATOR_CHARACTER: (["U+20D0"-"U+20FF"]) >
    | < OPERATOR_CHARACTER: (["U+FE00"-"U+FE0F"]) >
    | < OPERATOR_CHARACTER: (["U+FE20"-"U+FE2F"]) >
    | < OPERATOR_CHARACTER: (["U+E0100"-"U+E01EF"]) >


    /* ================================
                    Types
       ================================ */
    | < ANY: "any" >
    | < ARROW_RIGHT: "->">


    /* ================================
                    Annotation
       ================================ */
    | < INOUT: "inout" >


    /* ================================
                    Annotation
       ================================ */
    | < THROWS: "throws">
    | < RETHROWS: "rethrows">


    /* ================================
                    Metatype
       ================================ */
    | < CAPITAL_TYPE: "Type" >
    | < CAPITAL_PROTOCOL: "Protocol">


    /* ================================
                    Type Inheritance
       ================================ */
    | < CLASS: "class" >


    /* ================================
                    Try
       ================================ */
    | < TRY: "try" >


    /* ================================
                    Type-Casting
       ================================ */
    | < AS: "as" >
    | < IS: "is" >

    /* ================================
                    Self
       ================================ */
    | < SELF: "self" >
    | < INIT: "init" >


    /* ================================
                    Superclass
       ================================ */
    | < SUPER: "super" >


    /* ================================
                    Closure
       ================================ */
    | < IN: "in" >
    | < WEAK: "weak" >
    | < UNOWNED: "unowned" >
    | < SAFE: "safe" >
    | < UNSAFE: "unsafe" >


    /* ================================
                    Selector
       ================================ */
    | < SELECTOR: "#selector" >
    | < GETTER: "getter" >
    | < SETTER: "setter" >


    /* ================================
                    Key-Path
       ================================ */
    | < KEY_PATH: "#keyPath" >


    /* ================================
                    Dynamic Type
       ================================ */
    | < TYPE: "type" >
    | < OF: "of" >


    /* ================================
                    Dynamic Type
       ================================ */
    | < LET: "let" >
    | < VAR: "var" >


    /* ================================
                    Loops
       ================================ */
    | < WHILE: "while" >
    | < FOR: "for" >
    | < CASE: "case" >
    | < REPEAT: "repeat" >
    | < BREAK: "break" >
    | < CONTINUE: "continue" >


    /* ================================
                    Conditions
       ================================ */
    | < IF: "if" >
    | < ELSE: "else" >
    | < SWITCH: "switch" >
    | < DEFAULT: "default" >
    | < WHERE: "where" >


    /* ================================
                    Guard
       ================================ */
    | < GUARD: "guard" >


    /* ================================
                    Fallthrough
       ================================ */
    | < FALLTHROUGH: "fallthrough" >
    
    
    /* ================================
                    Return
       ================================ */
    | < RETURN: "return" >
    
    
    /* ================================
                    Throw
       ================================ */
    | < THROW: "throw" >
    
    
    /* ================================
                    Defer
       ================================ */
    | < DEFER: "defer" >
    
    
    /* ================================
                    Do
       ================================ */
    | < DO: "do" >
    | < CATCH: "catch" >
    
    
    /* ================================
                    Conditional Compilation
       ================================ */
    | < SHARP_IF: "#if" >
    | < SHARP_ELSEIF: "#elseif" >
    | < SHARP_ELSE: "#else" >
    | < SHARP_ENDIF: "#endif" >
    | < OS: "os" >
    | < ARCH: "arch" >
    | < SWIFT: "swift" >
    | < MAC_OS: "macOS" >
    | < IOS: "iOS" >
    | < WATCH_OS: "watchOS" >
    | < TV_OS: "tvOS" >
    | < I_386: "i386" >
    | < X_86_64: "x86_64" >
    | < ARM: "arm" >
    | < ARM_64: "arm64" >
    
    
    /* ================================
                    Line Control
       ================================ */
    | < SOURCE_LOCATION: "#sourceLocation" >
    | < FILE: "file" >
    | < LINE: "line" >


    /* ================================
                    Availability
       ================================ */
    | < SHARP_AVAILABLE: "#available" >
    | < IOS_APP_EXT: "iOSApplicationExtension" >
    | < MAC_OS_APP_EXT: "macOSApplicationExtension" >


    /* ================================
                    Import
       ================================ */
    | < IMPORT: "import" >
    | < TYPE_ALIAS: "typealias" >
    | < ENUM: "enum" >
    | < PROTOCOL: "protocol" >
    | < FUNC: "func" >


    /* ================================
                    Variable
       ================================ */
    | < GET: "get" >
    | < SET: "set" >
    | < WILL_SET: "willSet" >
    | < DID_SET: "didSet" >


    /* ================================
                    Enumeration
       ================================ */
    | < INDIRECT: "indirect" >


    /* ================================
                    Structure
       ================================ */
    | < STRUCT: "struct" >


    /* ================================
                    Class
       ================================ */
    | < FINAL: "final" >


    /* ================================
                    Associated Type
       ================================ */
    | < ASSOCIATED_TYPE: "associatedtype" >


    /* ================================
                    Deinitializer
       ================================ */
    | < DEINIT: "deinit" >


    /* ================================
                    Extension
       ================================ */
    | < EXTENSION: "extension" >


    /* ================================
                    Subscript
       ================================ */
    | < SUBSCRIPT: "subscript" >


    /* ================================
                    Operators
       ================================ */
    | < PREFIX: "prefix" >
    | < POSTFIX: "postfix" >
    | < INFIX: "infix" >
    | < OPERATOR: "operator" >


    /* ================================
                    Precedence Group
       ================================ */
    | < PRECEDENCE_GROUP: "precedencegroup" >
    | < HIGHER_THAN: "higherThan" >
    | < LOWER_THAN: "lowerThan" >
    | < ASSIGNMENT: "assignment" >
    | < ASSOCIATIVITY: "associativity" >
    | < LEFT: "left" >
    | < RIGHT: "right" >
    | < NONE: "none" >


    /* ================================
                    Declaration
       ================================ */
    | < CONVENIENCE: "convenience" >
    | < DYNAMIC: "dynamic" >
    | < INFIX: "infix" >
    | < LAZY: "lazy" >
    | < OPTIONAL: "optional" >
    | < OVERRIDE: "override" >
    | < POSTFIX: "postfix" >
    | < PREFIX: "prefix" >
    | < REQUIRED: "required" >
    | < STATIC: "static" >
    | < PRIVATE: "private" >
    | < FILEPRIVATE: "fileprivate"  >
    | < INTERNAL: "internal" >
    | < PUBLIC: "public" >
    | < OPEN: "open" >
    | < MUTATING: "mutating" >
    | < NON_MUTATING: "nonmutating" >


    /* ================================
                    Punctuation
       ================================ */
    | < DOT: "." >
    | < THREE_DOTS: "...">
    | < COMMA: "," >
    | < SEMICOLON: ";" >
    | < COLON: ":" >
    | < QUESTION_MARK: "?" >
    | < EXCLAMATION_MARK: "!" >
    | < SLASH: "/" >
    | < BACK_SLASH: "\\" >
    | < DOLLAR: "$" >
    | < AMPERSAND: "&" >
    | < DBL_AMPERSAND: "&&" >
    | < DBL_OR: "||" >
    | < AT: "@" >


    /* ================================
                    Brackets
       ================================ */
    | < OPEN_BRACKET: "{" >
    | < CLOSED_BRACKET: "}" >
    | < OPEN_SQUARE_BRACKET: "[" >
    | < CLOSED_SQUARE_BRACKET: "]" >
    | < OPEN_DOUBLE_QUOTE: "\"" >
    | < CLOSED_DOUBLE_QUOTE: "\"" >
    | < OPEN_PARENTHESIS: "(" >
    | < CLOSED_PARENTHESIS: ")" >
    | < OPEN_QUOTE: "`" >
    | < CLOSED_QUOTE: "`" >
    | < OPEN_TRIANGULAR_BRACKET: "<" >
    | < CLOSED_TRIANGULAR_BRACKET: ">" >



    | < EOL: "\n" >
}








/* =====================================================================================================================
                        1. Lexical Structure
   ================================================================================================================== */

/* ===================================================================
                        1.1. GRAMMAR OF AN IDENTIFIER
   =================================================================== */

void Identifier(): {}
{
    IdentifierHead() (IdentifierCharacter())?
    | <OPEN_QUOTE> IdentifierHead() (IdentifierCharacter())? <CLOSED_QUOTE>
    | ImplicitParameterName()
}

void IdentifierHead(): {}
{
    // TODO: Доделать и разобраться
    <UPPER_LETTER> |
    <LOWER_LETTER> |
    <UNDERSCORE> |
    <EXTENDED_UNICODE>
}

void IdentifierCharacter(): {}
{
    <DIGIT>
    | IdentifierHead()
}

void IdentifierCharacters(): {}
{
    IdentifierCharacter() (IdentifierCharacters())?
}

void ImplicitParameterName(): {}
{
    <DOLLAR> <DECIMAL_DIGIT>
}

/* ===================================================================
                        1.2. GRAMMAR OF A LITERAL
   =================================================================== */

void Literal(): {}
{
    NumericLiteral()
    | StringLiteral()
    | BooleanLiteral()
    | NilLiteral()
}

void NumericLiteral(): {}
{
    (<MINUS>)? IntegerLiteral()
    | (<MINUS>)? FloatingPointLiteral()
}

void BooleanLiteral(): {}
{
    <TRUE>
    | <FAlSE>
}

void NilLiteral(): {}
{
    <NIL>
}

/* ===================================================================
                        1.3. GRAMMAR OF AN INTEGER LITERAL (DONE)
   =================================================================== */

void IntegerLiteral(): {}
{
    BinaryLiteral()
    | OctalLiteral()
    | DecimalLiteral()
    | HexadecimalLiteral()
}

void BinaryLiteral(): {}
{
    <BINARY_DIGIT_BEGIN> <BINARY_DIGIT> (BinaryLiteralCharacter())?
}


void BinaryLiteralCharacter(): {}
{
    <BINARY_DIGIT>
    | <UNDERSCORE>
}

void OctalLiteral(): {}
{
    <OCTAL_DIGIT_BEGIN> <OCTAL_DIGIT> (OctalLiteralCharacters())?
}

void OctalLiteralCharacter(): {}
{
    <OCTAL_DIGIT>
    | <UNDERSCORE>
}

void OctalLiteralCharacters(): {}
{
    OctalLiteralCharacter() (OctalLiteralCharacters())?
}

void DecimalLiteral(): {}
{
    <DECIMAL_DIGIT> (DecimalLiteralCharacter())?
}

void DecimalDigits(): {}
{
    <DECIMAL_DIGIT> (DecimalDigits())?
}

void DecimalLiteralCharacter(): {}
{
    <DECIMAL_DIGIT>
    | <UNDERSCORE>
}

void DecimalLiteralCharacters(): {}
{
    DecimalLiteralCharacter() (DecimalLiteralCharacters())?
}

void HexadecimalLiteral(): {}
{
    <HEXADECIMAL_DIGIT_BEGIN> <HEXADECIMAL_DIGIT> (HexadecimalLiteralCharacters())?
}

void HexadecimalLiteralCharacter(): {}
{
    <HEXADECIMAL_DIGIT>
    | <UNDERSCORE>
}

void HexadecimalLiteralCharacters(): {}
{
    HexadecimalLiteralCharacter() (HexadecimalLiteralCharacters())?
}

/* ===================================================================
                        1.4. GRAMMAR OF A FLOATING-POINT LITERAL (DONE)
   =================================================================== */

void FloatingPointLiteral(): {}
{
    DecimalLiteral() (DecimalFraction())? (DecimalExponent())?
}

void DecimalFraction(): {}
{
    <DOT> DecimalLiteral()
}

void DecimalExponent(): {}
{
    <E> (<PLUS>)? DecimalLiteral()
    | <E> (<MINUS>)? DecimalLiteral()
}

void HexadecimalFraction(): {}
{
    <DOT> <HEXADECIMAL_DIGIT>
    | <DOT> <HEXADECIMAL_DIGIT> HexadecimalLiteralCharacters()
}

void HexadecimalExponent(): {}
{
    <P> (<PLUS>)? DecimalLiteral()
    | <P> (<MINUS>)? DecimalLiteral()
}

/* ===================================================================
                        1.5. GRAMMAR OF A STRING LITERAL
   =================================================================== */

void StringLiteral(): {}
{
    StaticStringLiteral()
    | InterpolatedStringLiteral()
}

void StaticStringLiteral(): {}
{
    <OPEN_DOUBLE_QUOTE> (QuotedText())? <CLOSED_DOUBLE_QUOTE>
}

void QuotedText(): {}
{
    QuotedTextItem() (QuotedText())?
}

void QuotedTextItem(): {}
{
    <ESCAPE_CHARACTERS>
    // TODO Any Unicode scalar value except "­, \­, U+000A, or U+000D
}

void InterpolatedStringLiteral(): {}
{
    <OPEN_DOUBLE_QUOTE> (InterpolatedText())? <CLOSED_DOUBLE_QUOTE>
}

void InterpolatedText(): {}
{
    InterpolatedTextItem() (InterpolatedText())?
}

void InterpolatedTextItem(): {}
{
    <BACK_SLASH> <OPEN_PARENTHESIS> Expression() <CLOSED_PARENTHESIS>
    | QuotedTextItem()
}

/* ===================================================================
                        1.6. GRAMMAR OF OPERATORS
   =================================================================== */
// TODO: Доделать весь раздел

void Operator(): {}
{
    // TODO: Доделать
    <NIL>
}

void OperatorHead(): {}
{
    // TODO: Доделать
    <NIL>
}

void OperatorCharacter(): {}
{
    // TODO: Доделать
    <NIL>
}

void OperatorCharacters(): {}
{
    OperatorCharacter() (OperatorCharacters())?
}


/* =====================================================================================================================
                        2. Lexical Structure
   ================================================================================================================== */

/* ===================================================================
                        2.1. GRAMMAR OF A TYPE
   =================================================================== */

void Type(): {}
{
    ArrayType()
    | DictionaryType()
    | FunctionType()
    | TypeIdentifier()
    | TupleType()
    | OptionalType()
    | ImplicitlyUnwrappedOptionalType()
    | ProtocolCompositionType()
    | MetatypeType()
    | <ANY>
    | <SELF>
}

/* ===================================================================
                        2.2. GRAMMAR OF A TYPE ANNOTATION
   =================================================================== */

void TypeAnnotation(): {}
{
    <COLON> (Attributes())? (<INOUT>)? Type()
}

/* ===================================================================
                        2.3. GRAMMAR OF A TYPE IDENTIFIER
   =================================================================== */

void TypeIdentifier(): {}
{
    TypeName() (GenericArgumentClause())?
    | TypeName() (GenericArgumentClause())? <DOT> TypeIdentifier()
}

void TypeName(): {
}
{
    Identifier()
}

/* ===================================================================
                        2.4. GRAMMAR OF A TUPLE TYPE
   =================================================================== */

void TupleType(): {}
{
    <OPEN_PARENTHESIS> (TupleTypeElementList())? <CLOSED_PARENTHESIS>
}

void TupleTypeElementList(): {}
{
    TupleTypeElement() |
    TupleTypeElement() <COMMA> TupleTypeElementList()
}

void TupleTypeElement(): {}
{
    ElementName() TypeAnnotation()| Type()
}

void ElementName(): {}
{
    Identifier()
}

/* ===================================================================
                        2.5. GRAMMAR OF A FUNCTION TYPE
   =================================================================== */

void FunctionType(): {}
{
    (Attributes())? FunctionTypeArgumentClause() (<THROWS>)? <ARROW_RIGHT> Type() |
    (Attributes())? FunctionTypeArgumentClause() <RETHROWS> <ARROW_RIGHT> Type()
}

void FunctionTypeArgumentClause(): {}
{
    <OPEN_PARENTHESIS> <CLOSED_PARENTHESIS> |
    <OPEN_PARENTHESIS> FunctionTypeArgumentList() <CLOSED_PARENTHESIS> (<THREE_DOTS>)?
}

void FunctionTypeArgumentList(): {}
{
    FunctionTypeArgument() |
    FunctionTypeArgument() <COMMA> FunctionTypeArgumentList()
}

void FunctionTypeArgument(): {}
{
    (Attributes())? (<INOUT>)? Type() |
    ArgumentLabel() TypeAnnotation()
}

void ArgumentLabel(): {}
{
    Identifier()
}

/* ===================================================================
                        2.6. GRAMMAR OF AN ARRAY TYPE
   =================================================================== */

void ArrayType(): {}
{
    <OPEN_SQUARE_BRACKET> Type() <CLOSED_SQUARE_BRACKET>
}

/* ===================================================================
                        2.7. GRAMMAR OF A DICTIONARY TYPE
   =================================================================== */

void DictionaryType(): {}
{
    <OPEN_SQUARE_BRACKET> Type() <COLON> Type() <CLOSED_SQUARE_BRACKET>
}

/* ===================================================================
                        2.8. GRAMMAR OF AN OPTIONAL TYPE
   =================================================================== */

void OptionalType(): {}
{
    Type() <QUESTION_MARK>
}

/* ===================================================================
                        2.9. GRAMMAR OF AN IMPLICITLY UNWRAPPED OPTIONAL TYPE
   =================================================================== */

void ImplicitlyUnwrappedOptionalType(): {}
{
    Type() <EXCLAMATION_MARK>
}

/* ===================================================================
                        2.10. GRAMMAR OF A PROTOCOL COMPOSITION TYPE
   =================================================================== */

void ProtocolCompositionType(): {}
{
    ProtocolIdentifier() <AMPERSAND> ProtocolCompositionContinuation()
}

void ProtocolCompositionContinuation(): {}
{
    ProtocolIdentifier() ProtocolCompositionType()
}

void ProtocolIdentifier(): {}
{
    TypeIdentifier()
}

/* ===================================================================
                        2.11. GRAMMAR OF A METATYPE TYPE
   =================================================================== */

void MetatypeType(): {}
{
    Type() <DOT> <TYPE>
    | Type() <DOT> <CAPITAL_PROTOCOL>
}

/* ===================================================================
                        2.12. GRAMMAR OF A TYPE INHERITANCE CLAUSE
   =================================================================== */

void TypeInheritanceClause(): {}
{
    <COLON> <CLASS> <COMMA> TypeInheritanceList()
    | <COLON> <CLASS>
    | <COLON> TypeInheritanceList()
}

void TypeInheritanceList(): {}
{
    TypeIdentifier()
    | TypeIdentifier() <COMMA> TypeInheritanceList()
}

/* =====================================================================================================================
                        3. Expressions
   ================================================================================================================== */

/* ===================================================================
                        3.1. GRAMMAR OF AN EXPRESSION
   =================================================================== */

void Expression(): {}
{
    (<TRY>)? PrefixExpression() (BinaryExpressions())?
}

void ExpressionList(): {}
{
    Expression()
    | Expression() <COMMA> ExpressionList()
}

/* ===================================================================
                        3.2. GRAMMAR OF A PREFIX EXPRESSION
   =================================================================== */

void PrefixExpression(): {}
{
    (PrefixOperator())? PostfixExpression()
    | InOutExpression()
}

void InOutExpression(): {}
{
    <AMPERSAND> Identifier()
}

// TODO:  Grammar of a try expression

/* ===================================================================
                        3.3. GRAMMAR OF A BINARY EXPRESSION
   =================================================================== */

void BinaryExpression(): {}
{
    BinaryOperator() PrefixExpression()
    | <ASSIGN> (<TRY>)? PrefixExpression()
    | ConditionalOperator() (<TRY>)? PrefixExpression()
    | TypeCastingOperator()
}

void BinaryExpression(): {}
{
    BinaryExpression() (BinaryExpressions())?
}

/* ===================================================================
                        3.4. GRAMMAR OF A CONDITIONAL OPERATOR
   =================================================================== */

void ConditionalOperator(): {}
{
    <QUESTION_MARK> (<TRY>)? Expression() <COLON>
}

/* ===================================================================
                        3.5. GRAMMAR OF A TYPE-CASTING OPERATOR
   =================================================================== */

void TypeCastingOperator(): {}
{
    <IS> Type()
    | <AS> Type()
    | <AS> <QUESTION_MARK> Type()
    | <AS> <EXCLAMATION_MARK> Type()
}

/* ===================================================================
                        3.6. GRAMMAR OF A PRIMARY EXPRESSION
   =================================================================== */

void PrimaryExpression(): {}
{
    Identifier() (GenericArgumentClause())?
    | LiteralExpression()
    | SelfExpression()
    | SuperclassExpression()
    | ClojureExpression()
    | ParenthesizedExpression()
    | TupleExpression()
    | ImplicitMemberExpression()
    | WildcardExpression()
    | SelectorExpression()
    | KeyPathExpression()
}

/* ===================================================================
                        3.7. GRAMMAR OF A LITERAL EXPRESSION
   =================================================================== */

void LiteralExpression(): {}
{
    Literal()
    | ArrayLiteral()
    | DictionaryLiteral()
    | PlaygroundLiteral()
    | <SHARP_FILE>
    | <SHARP_LINE>
    | <COLUMN>
    | <FUNCTION>
}

void ArrayLiteral(): {}
{
    <OPEN_SQUARE_BRACKET> (ArrayLiteralItems())? <CLOSED_SQUARE_BRACKET>
}

void ArrayLiteralItems(): {}
{
    ArrayLiteralItem() (<COMMA>)?
    | ArrayLiteralItem() <COMMA> ArrayLiteralItems()
}

void ArrayLiteralItem(): {}
{
    Expression()
}

void DictionaryLiteral(): {}
{
    <OPEN_SQUARE_BRACKET> DictionaryLiteralItems() <CLOSED_SQUARE_BRACKET>
    | <OPEN_SQUARE_BRACKET> <COLON> <CLOSED_SQUARE_BRACKET>
}

void DictionaryLiteralItems(): {}
{
    DictionaryLiteralItem() (<COMMA>)?
    | DictionaryLiteralItem() <COMMA> DictionaryLiteralItems()
}

void DictionaryLiteralItem(): {}
{
    Expression() <COLON> Expression()
}

void PlaygroundLiteral(): {}
{
    <COLOR_LITERAL> <OPEN_PARENTHESIS> <RED> <COLON> Expression() <COMMA> <GREEN> <COLON> Expression() <COMMA> <BLUE> <COLON> Expression() <COMMA> <ALPHA> <COLON> Expression() <CLOSED_PARENTHESIS>
    | <FILE_LITERAL> <OPEN_PARENTHESIS> <RESOURCE_NAME> <COLON> Expression() <CLOSED_PARENTHESIS>
    | <IMAGE_LITERAL> <OPEN_PARENTHESIS> <RESOURCE_NAME> <COLON> Expression() <CLOSED_PARENTHESIS>
}

/* ===================================================================
                        3.8. GRAMMAR OF A SELF EXPRESSION
   =================================================================== */

void SelfExpression(): {}
{
    <SELF>
    | SelfMethodExpression()
    | SelfSubscriptExpression()
    | SelfInitializerExpression()
}

void SelfMethodExpression(): {}
{
    <SELF> <DOT> Identifier()
}

void SelfSubscriptExpression(): {}
{
    <SELF> <OPEN_SQUARE_BRACKET> ExpressionList() <CLOSED_SQUARE_BRACKET>
}

void SelfInitializerExpression(): {}
{
    <SELF> <DOT> <INIT>
}

/* ===================================================================
                        3.9. GRAMMAR OF A SUPERCLASS EXPRESSION (DONE)
   =================================================================== */

void SuperclassExpression(): {}
{
    SuperclassMethodExpression()
    | SuperclassSubscriptExpression()
    | SuperclassInitializerExpression()
}

void SuperclassMethodExpression(): {}
{
    <SUPER> <DOT> Identifier()
}

void SuperclassSubscriptExpression(): {}
{
    <SUPER> <OPEN_SQUARE_BRACKET> ExpressionList() <CLOSED_SQUARE_BRACKET>
}

void SuperclassInitializerExpression(): {}
{
    <SUPER> <DOT> <INIT>
}

/* ===================================================================
                        3.10. GRAMMAR OF A CLOSURE EXPRESSION
   =================================================================== */

void ClosureExpression(): {}
{
    <OPEN_BRACKET> (ClosureSignature())? (Statements())? <CLOSED_BRACKET>
}

void ClosureSignature(): {}
{
    (CaptureList())? ClosureParameterClause() (<THROWS>)? (FunctionResult())? <IN>
    | CaptureList() <IN>
}

void ClosureParameterClause(): {}
{
    <OPEN_PARENTHESIS> <CLOSED_PARENTHESIS>
    | <OPEN_PARENTHESIS> ClosureParameterList() <CLOSED_PARENTHESIS>
    | IdentifierList()
}

void ClosureParameterList(): {}
{
    ClosureParameter() ClosureParameter() <COMMA> ClosureParameterList()
}

void ClosureParameter(): {}
{
    ClosureParameterName() (TypeAnnotation())?
    | ClosureParameterName() TypeAnnotation() <THREE_DOTS>
}

void ClosureParameterName(): {}
{
    Identifier()
}

void CaptureList(): {}
{
    <OPEN_SQUARE_BRACKET> CaptureListItems() <CLOSED_SQUARE_BRACKET>
}

void CaptureListItems(): {}
{
    CaptureListItem()
    | CaptureListItem() <COMMA> CaptureListItems()
}

void CaptureListItem(): {}
{
    (CaptureSpecifier())? Expression()
}

void CaptureSpecifier(): {}
{
    // TODO: Доделать
    <WEAK>
    | <UNOWNED>
    | <UNOWNED> <OPEN_PARENTHESIS> <SAFE> <CLOSED_PARENTHESIS>
    | <UNOWNED> <OPEN_PARENTHESIS> <UNSAFE> <CLOSED_PARENTHESIS>
}

/* ===================================================================
                        3.11. GRAMMAR OF A IMPLICIT MEMBER EXPRESSION
   =================================================================== */

void ImplicitMemberExpression(): {}
{
    <DOT> Expression()
}

/* ===================================================================
                        3.12. GRAMMAR OF A PARENTHESIZED EXPRESSION
   =================================================================== */

void ParenthesizedExpression(): {}
{
    <OPEN_PARENTHESIS> Expression() <CLOSED_PARENTHESIS>
}

/* ===================================================================
                        3.13. GRAMMAR OF A TUPLE EXPRESSION
   =================================================================== */

void TupleExpression(): {}
{
    <OPEN_PARENTHESIS> <CLOSED_PARENTHESIS>
    | <OPEN_PARENTHESIS> TupleElement() <COMMA> TupleElementList() <CLOSED_PARENTHESIS>

}

void TupleElementList(): {}
{
    TupleElement()
    | TupleElement() <COMMA> TupleTypeElementList()
}

void TupleElement(): {}
{
    Expression()
    | Identifier() <COLON> Expression()
}

/* ===================================================================
                        3.14. GRAMMAR OF A WILDCARD EXPRESSION
   =================================================================== */

void WildcardExpression(): {}
{
    <UNDERSCORE>
}

/* ===================================================================
                        3.15. GRAMMAR OF A SELECTOR EXPRESSION
   =================================================================== */

void SelectorExpression(): {}
{
    // TODO: Проверить можно ли так поступать с селектором
    <SELECTOR> <OPEN_PARENTHESIS> Expression() <CLOSED_PARENTHESIS>
    | <SELECTOR> <OPEN_PARENTHESIS> <GETTER> <COLON> Expression() <CLOSED_PARENTHESIS>
    | <SELECTOR> <OPEN_PARENTHESIS> <SETTER> <COLON> Expression() <CLOSED_PARENTHESIS>

}

/* ===================================================================
                        3.16. GRAMMAR OF A KEY-PATH EXPRESSION
   =================================================================== */

void KeyPathExpression(): {}
{
    <KEY_PATH> <OPEN_PARENTHESIS> Expression() <CLOSED_PARENTHESIS>
}

/* ===================================================================
                        3.17. GRAMMAR OF A POSTFIX EXPRESSION (DONE)
   =================================================================== */

void PostfixExpression(): {}
{
    PrimaryExpression()
    | PostfixExpression() PostfixOperator()
    | FunctionCallExpression()
    | InitializerExpression()
    | ExplicitMemberExpression()
    | PostfixSelfExpression()
    | DynamicTypeExpression()
    | SubscriptExpression()
    | ForcedValueExpression()
    | OptionalChainingExpression()
}

/* ===================================================================
                        3.18. GRAMMAR OF A FUNCTIONAL CALL EXPRESSION (DONE)
   =================================================================== */

void FunctionCallExpression(): {}
{
    PostfixExpression() FunctionCallArgumentClause()
    | PostfixExpression() (FunctionCallArgumentClause())? TrailingClosure()
}

void FunctionCallArgumentClause(): {}
{
    <OPEN_PARENTHESIS> <CLOSED_PARENTHESIS>
    | <OPEN_PARENTHESIS> FunctionCallArgumentList() <CLOSED_PARENTHESIS>
}

void FunctionCallArgumentList(): {}
{
    FunctionCallArgument()
    | FunctionCallArgument() <COMMA> FunctionCallArgumentList()
}

void FunctionCallArgument(): {}
{
    Expression()
    | Identifier() <COLON> Expression()
    | Operator()
    | Identifier() <COLON> Operator()
}

void TrailingClosure(): {}
{
    ClosureExpression()
}

/* ===================================================================
                        3.19. GRAMMAR OF AN INITIALIZER EXPRESSION
   =================================================================== */

void InitializerExpression(): {}
{
    PostfixExpression() <DOT> <INIT>
    | PostfixExpression() <DOT> <INIT> <OPEN_PARENTHESIS> ArgumentNames() <CLOSED_PARENTHESIS>
}

/* ===================================================================
                        3.20. GRAMMAR OF AN EXPLICIT MEMBER EXPRESSION
   =================================================================== */

void ExplicitMemberExpression(): {}
{
    PostfixExpression() <DOT> DecimalDigits()
    | PostfixExpression() <DOT> Identifier() (GenericArgumentClause())?
    | PostfixExpression() <DOT> Identifier() <OPEN_PARENTHESIS> ArgumentNames() <CLOSED_PARENTHESIS>
}

void ArgumentNames(): {}
{
    ArgumentName() (ArgumentNames())?
}

void ArgumentName(): {}
{
    Identifier() <COLON>
}

/* ===================================================================
                        3.21. GRAMMAR OF A SELF EXPRESSION (DONE)
   =================================================================== */

void PostfixSelfExpression(): {}
{
    PostfixExpression() <DOT> <SELF>
}

/* ===================================================================
                        3.22. GRAMMAR OF A DYNAMIC TYPE EXPRESSION (DONE)
   =================================================================== */

void DynamicTypeExpression(): {}
{
    <TYPE> <OPEN_PARENTHESIS> <OF> <COLON> Expression() <CLOSED_PARENTHESIS>
}

/* ===================================================================
                        3.23. GRAMMAR OF A SUBSCRIPT EXPRESSION
   =================================================================== */

void SubscriptExpression(): {}
{
     PostfixExpression() <OPEN_SQUARE_BRACKET> ExpressionList() <CLOSED_SQUARE_BRACKET>
}

/* ===================================================================
                        3.24. GRAMMAR OF A FORCED-VALUE EXPRESSION
   =================================================================== */

void ForcedValueExpression(): {}
{
    PostfixExpression() <EXCLAMATION_MARK>
}

/* ===================================================================
                        3.25. GRAMMAR OF AN OPTIONAL-CHAINING EXPRESSION
   =================================================================== */

void OptionalChainingExpression(): {}
{
    PostfixExpression() <QUESTION_MARK>
}


/* =====================================================================================================================
                        4. Statements
   ================================================================================================================== */


/* ===================================================================
                        4.1. GRAMMAR OF A STATEMENT
   =================================================================== */
void Statement(): {}
{
    Expression() (<SEMICOLON>)?
    | Declaration() (<SEMICOLON>)?
    | LoopStatement() (<SEMICOLON>)?
    | BranchStatement() (<SEMICOLON>)?
    | LabeledStatement() (<SEMICOLON>)?
    | ControlTransferStatement() (<SEMICOLON>)?
    | DeferStatement() (<SEMICOLON>)?
    | DoStatement() (<SEMICOLON>)?
    | CompilerControlStatement() (<SEMICOLON>)?
}

void Statements(): {}
{
    Statement() (Statements())?
}


/* ===================================================================
                        4.2. GRAMMAR OF A LOOP STATEMENT
   =================================================================== */
void LoopStatement(): {}
{
    ForInStatement()
    | WhileStatement()
    | RepeatWhileStatement()
}


/* ===================================================================
                        4.3. GRAMMAR OF A FOR-IN STATEMENT
   =================================================================== */
void ForInStatement(): {}
{
    <FOR> (<CASE>)? Pattern() <IN> Expression() (WhereClause())? CodeBlock()
}


/* ===================================================================
                        4.4. GRAMMAR OF A WHILE STATEMENT
   =================================================================== */
void WhileStatement(): {}
{
    <WHILE> ConditionList() CodeBlock()
}

void ConditionList(): {}
{
    Condition()
    | Condition() <COMMA> ConditionList()
}

void Condition(): {}
{
    Expression()
    | AvailabilityCondition()
    | CaseCondition()
    | OptionalBridgingCondition()
}

void CaseCondition(): {}
{
    <CASE> Pattern() Initializer()
}

void OptionalBridgingCondition(): {}
{
    <LET> Pattern() Initializer()
    | <VAR> Pattern() Initializer()
}


/* ===================================================================
                        4.5. GRAMMAR OF A REPEAT-WHILE STATEMENT
   =================================================================== */
void RepeatWhileStatement(): {}
{
    <REPEAT> CodeBlock() <WHILE> Expression()
}


/* ===================================================================
                        4.6. GRAMMAR OF A BRANCH STATEMENT
   =================================================================== */
void BranchStatement(): {}
{
    IfStatement()
    | GuardStatement()
    | SwitchStatement()
}


/* ===================================================================
                        4.7. GRAMMAR OF AN IF STATEMENT
   =================================================================== */
void IfStatement(): {}
{
    <IF> ConditionList() CodeBlock() (ElseClause())?
}

void ElseClause(): {}
{
    <ELSE> CodeBlock()
    | <ELSE> IfStatement()
}


/* ===================================================================
                        4.8. GRAMMAR OF A GUARD STATEMENT
   =================================================================== */
void GuardStatement(): {}
{
    <GUARD> ConditionList() <ELSE> CodeBlock()
}


/* ===================================================================
                        4.9. GRAMMAR OF A SWITCH STATEMENT
   =================================================================== */
void SwitchStatement(): {}
{
    <SWITCH> Expression() <OPEN_BRACKET> (SwitchCases())? <CLOSED_BRACKET>
}

void SwitchCases(): {}
{
    SwitchCase() (SwitchCases())?
}

void SwitchCase(): {}
{
    CaseLabel() Statements()
    | DefaultLabel() Statements()
}

void CaseLabel(): {}
{
    <CASE> CaseItemList() <COLON>
}

void CaseItemList(): {}
{
    Pattern() (WhereClause())?
    | Pattern() (WhereClause())? <COMMA> CaseItemList()
}

void DefaultLabel(): {}
{
    <DEFAULT> <COLON>
}

void WhereClause(): {}
{
    <WHERE> WhereExpression()
}

void WhereExpression(): {}
{
    Expression()
}


/* ===================================================================
                        4.10. GRAMMAR OF A LABELED STATEMENT
   =================================================================== */
void LabeledStatement(): {}
{
    StatementLabel() LoopStatement()
    | StatementLable() IfStatement()
    | StatementLable() SwitchStatement()
    | StatementLable() DoStatement()
}

void StatementLabel(): {}
{
    LabelName() <COLON>
}

void LabelName(): {}
{
    Identifier()
}


/* ===================================================================
                        4.11. GRAMMAR OF A CONTROL TRANSFER STATEMENT
   =================================================================== */
void ControlTransferStatement(): {}
{
    BreakStatement()
    | ContinueStatement()
    | FallthroughStatement()
    | ReturnStatement()
    | ThrowStatement()
}


/* ===================================================================
                        4.12. GRAMMAR OF A BREAK STATEMENT
   =================================================================== */
void BreakStatement(): {}
{
    <BREAK> (LabelName())?
}


/* ===================================================================
                        4.13. GRAMMAR OF A CONTINUE STATEMENT
   =================================================================== */
void ContinueStatement(): {}
{
    <CONTINUE> (LabelName())?
}


/* ===================================================================
                        4.14. GRAMMAR OF A FALLTHROUGH STATEMENT
   =================================================================== */
void FallthroughStatement(): {}
{
    <FALLTHROUGH>
}


/* ===================================================================
                        4.15. GRAMMAR OF A RETURN STATEMENT
   =================================================================== */
void ReturnStatement(): {}
{
    <RETURN> (Expression())?
}


/* ===================================================================
                        4.16. GRAMMAR OF A THROW STATEMENT
   =================================================================== */
void ThrowStatement(): {}
{
    <THROW> Expression()
}


/* ===================================================================
                        4.17. GRAMMAR OF A DEFER STATEMENT
   =================================================================== */
void DeferStatement(): {}
{
    <DEFER> CodeBlock()
}


/* ===================================================================
                        4.18. GRAMMAR OF A DO STATEMENT
   =================================================================== */
void DoStatement(): {}
{
    <DO> CodeBlock() (CatchClauses())?
}

void CatchClauses(): {}
{
    CatchClause() (CatchClauses())?
}

void CatchClause(): {}
{
    <CATCH> (Pattern())? (WhereClause())? CodeBlock()
}


/* ===================================================================
                        4.19. GRAMMAR OF A COMPILER CONTROL STATEMENT
   =================================================================== */
void CompilerControlStatement(): {}
{
    ConditionalCompilationBlock()
    | LineControlStatement()
}


/* ===================================================================
                        4.20. GRAMMAR OF A CONDITIONAL COMPILATION BLOCK
   =================================================================== */
void ConditionalCompilationBlock(): {}
{
    IfDirectiveClause() (ElseifDirectiveClauses())? (ElseDirectiveClause())? EndifDirective()
}


void IfDirectiveClause(): {}
{
    IfDirective() CompilationCondition() (Statements())?
}

void ElseifDirectiveClauses(): {}
{
    ElseifDirectiveClause() (ElseifDirectiveClauses())?
}

void ElseifDirectiveClause(): {}
{
    ElseifDirective() CompilationCondition() (Statements())?
}

void ElseDirectiveClause(): {}
{
    ElseDirective() (Statements())?
}


void IfDirective(): {}
{
    <SHARP_IF>
}

void ElseifDirective(): {}
{
    <SHARP_ELSEIF>
}

void ElseDirective(): {}
{
    <SHARP_ELSE>
}

void EndifDirective(): {}
{
    <SHARP_ENDIF>
}


void CompilationCondition(): {}
{
    PlatformCondition()
    | Identifier()
    | BooleanLiteral()
    | <OPEN_PARENTHESIS> CompilationCondition() <CLOSED_PARENTHESIS>
    | <EXCLAMATION_MARK> CompilationCondition()
    | CompilationCondition() <DBL_AMPERSAND> CompilationCondition()
    | CompilationCondition() <DBL_OR> CompilationCondition()
}


void PlatformCondition(): {}
{
    <OS> <OPEN_PARENTHESIS> OperatingSystem() <CLOSED_PARENTHESIS>
    | <ARCH> <OPEN_PARENTHESIS> Architecture() <CLOSED_PARENTHESIS>
    | <SWIFT> <OPEN_PARENTHESIS> <MORE_OR_EQUALS> SwiftVersion() <CLOSED_PARENTHESIS>
}

void OperatingSystem(): {}
{
    <MAC_OS>
    | <IOS>
    | <WATCH_OS>
    | <TV_OS>
}

void Architecture(): {}
{
    <I_386>
    | <X_86_64>
    | <ARM>
    | <ARM_64>
}

void SwiftVersion(): {}
{
    DecimalDigits() (SwiftVersionConfiguration())?
}

void SwiftVersionConfiguration(): {}
{
    <DOT> DecimalDigits() (SwiftVersionConfiguration())?
}


/* ===================================================================
                        4.21. GRAMMAR OF A LINE CONTROL STATEMENT
   =================================================================== */
void LineControlStatement(): {}
{
    <SOURCE_LOCATION> <OPEN_PARENTHESIS> <FILE> FileName() <COMMA> <LINE> LineNumber() <CLOSED_PARENTHESIS> //TODO decide on colon "file:"
    | <SOURCE_LOCATION> <OPEN_PARENTHESIS> <CLOSED_PARENTHESIS>
}

void LineNumber(): {}
{
    DecimalDigits()
}

void FileName(): {}
{
    StaticStringLiteral()
}


/* ===================================================================
                        4.22. GRAMMAR OF AN AVAILABILITY CONDITION
   =================================================================== */
void AvailabilityCondition(): {}
{
    <SHARP_AVAILABLE> <OPEN_PARENTHESIS> AvailabilityArguments() <CLOSED_PARENTHESIS>
}

void AvailabilityArguments(): {}
{
    AvailabilityArgument()
    | AvailabilityArgument() <COMMA> AvailabilityArguments()
}

void AvailabilityArgument(): {}
{
    PlatformName() PlatformVersion()
    | <STAR>
}

void PlatformName(): {}
{
    <IOS>
    | <IOS_APP_EXT>
    | <MAC_OS>
    | <MAC_OS_APP_EXT>
    | <WATCH_OS>
    | <TV_OS>
}

void PlatformVersion(): {}
{
    DecimalDigits()
    | DecimalDigits() <DOT> DecimalDigits()
    | DecimalDigits() <DOT> DecimalDigits() <DOT> DecimalDigits()
}



/* =====================================================================================================================
                        5. Declarations
   ================================================================================================================== */


/* ===================================================================
                        5.1. GRAMMAR OF A DECLARATION
   =================================================================== */

void Declaration(): {}
{
    ImportDeclaration()
    | ConstantDeclaration()
    | VariableDeclaration()
    | TypealiasDeclaration()
    | FunctionDeclaration()
    | EnumDeclaration()
    | StructDeclaration()
    | ClassDeclaration()
    | ProtocolDeclaration()
    | InitializerDeclaration()
    | DeinitializerDeclaration()
    | ExtensionDeclaration()
    | SubscriptDeclaration()
    | OperatorDeclaration()
    | PrecedenceGroupDeclaration()
}

void Declarations(): {}
{
    Declaration() (Declarations())?
}

/* ===================================================================
                        5.2. GRAMMAR OF A TOP-LEVEL DECLARATION
   =================================================================== */

void TopLevelDeclaration(): {}
{
    (Statements())?
}

/* ===================================================================
                        5.3. GRAMMAR OF A CODE BLOCK
   =================================================================== */

void CodeBlock(): {}
{
    <OPEN_BRACKET> (Statements())? <CLOSED_BRACKET>
}

/* ===================================================================
                        5.4. GRAMMAR OF AN IMPORT DECLARATION
   =================================================================== */
void ImportDeclaration(): {}
{
    (Attributes())? <IMPORT> (ImportKind())? ImportPath()
}


void ImportKind(): {}
{
    <TYPE_ALIAS>
    | <STRUCT>
    | <CLASS>
    | <ENUM>
    | <PROTOCOL>
    | <VAR>
    | <FUNC>
}

void ImportPath(): {}
{
    ImportPathIdentifier()
    | ImportPathIdentifier() <DOT> ImportPath()
}

void ImportPathIdentifier(): {}
{
    Identifier()
    | Operator()
}


/* ===================================================================
                        5.5. GRAMMAR OF A CONSTANT DECLARATION
   =================================================================== */
void ConstantDeclaration(): {}
{
    (Attributes())? (DeclarationModifiers())? <LET> PatternInitializerList()
}


void PatternInitializerList(): {}
{
    PatternInitializer()
    | PatternInitializer() <COMMA> PatternInitializerList()
}

void PatternInitializer(): {}
{
    Pattern() (Initializer())?
}

void Initializer(): {}
{
    <ASSIGN> Expression()
}


/* ===================================================================
                        5.6. GRAMMAR OF A VARIABLE DECLARATION
   =================================================================== */
void VariableDeclaration(): {}
{
    VariableDeclarationHead() PatternInitializerList()
    | VariableDeclarationHead() VariableName() TypeAnnotation() CodeBlock()
    | VariableDeclarationHead() VariableName() TypeAnnotation() GetterSetterBlock()
    | VariableDeclarationHead() VariableName() TypeAnnotation() GetterSetterKeywordBlock()
    | VariableDeclarationHead() VariableName() Initializer() WillSetDidSetBlock()
    | VariableDeclarationHead() VariableName() TypeAnnotation() (Initializer())? WillSetDidSetBlock()
}


void VariableDeclarationHead(): {}
{
    (Attributes())? (DeclarationModifiers())? <VAR>
}

void VariableName(): {}
{
    Identifier()
}


void GetterSetterBlock(): {}
{
    CodeBlock()
    | <OPEN_BRACKET> GetterClause() (SetterClause())? <CLOSED_BRACKET>
    | <OPEN_BRACKET> SetterClause() GetterClause() <CLOSED_BRACKET>
}

void GetterClause(): {}
{
    (Attributes())? (MutationModifier())? <GET> CodeBlock()
}

void SetterClause(): {}
{
   (Attributes())? (MutationModifier())? <SET> (SetterName())? CodeBlock()
}

void SetterName(): {}
{
    <OPEN_PARENTHESIS> Identifier() <CLOSED_PARENTHESIS>
}


void GetterSetterKeywordBlock(): {}
{
    <OPEN_BRACKET> GetterKeywordClause() (SetterKeywordClause())? <CLOSED_BRACKET>
    | <OPEN_BRACKET> SetterKeywordClause() GetterKeywordClause() <CLOSED_BRACKET>
}

void GetterKeywordClause(): {}
{
    (Attributes())? (MutationModifier())? <GET>
}

void SetterKeywordClause(): {}
{
   (Attributes())? (MutationModifier())? <SET>
}


void WillSetDidSetBlock(): {}
{
    <OPEN_BRACKET> WillSetClause() (DidSetClause())? <CLOSED_BRACKET>
    | <OPEN_BRACKET> DidSetClause() (WillSetClause())? <CLOSED_BRACKET>
}

void WillSetClause(): {}
{
    (Attributes())? <WILL_SET> (SetterName())? CodeBlock()
}

void DidSetClause(): {}
{
   (Attributes())? <DID_SET> (SetterName())? CodeBlock()
}



/* ===================================================================
                        5.7. GRAMMAR OF A TYPE ALIAS DECLARATION
   =================================================================== */
void TypealiasDeclaration(): {}
{
    (Attributes())? (AccessLevelModifier())? <TYPE_ALIAS> TypealiasName() (GenericParameterClause())? TypealiasAssignment()
}

void TypealiasName(): {}
{
    Identifier()
}

void TypealiasAssignment(): {}
{
    <ASSIGN> Type()
}


/* ===================================================================
                        5.8. GRAMMAR OF A FUNCTION DECLARATION
   =================================================================== */
void FunctionDeclaration(): {}
{
    FunctionHead() FunctionName() (GenericParameterClause())? FunctionSignature() (GenericWhereClause())? (FunctionBody())?
}


void FunctionHead(): {}
{
    (Attributes())? (DeclarationModifiers())? <FUNC>
}

void FunctionName(): {}
{
    Identifier()
    | Operator()
}


void FunctionSignature(): {}
{
    ParameterClause() (<THROWS>)? (FunctionResult())?
    | ParameterClause() <RETHROWS> (FunctionResult())?
}

void FunctionResult(): {}
{
    <ARROW_RIGHT> (Attributes())? Type()
}

void FunctionBody(): {}
{
    CodeBlock()
}


void ParameterClause(): {}
{
    <OPEN_PARENTHESIS> <CLOSED_PARENTHESIS>
    | <OPEN_PARENTHESIS> ParameterList() <CLOSED_PARENTHESIS>
}

void ParameterList(): {}
{
    Parameter()
    | Parameter() <COMMA> ParameterList()
}

void Parameter(): {}
{
    (ExternalParameterName())? LocalParameterName() TypeAnnotation() (DefaultArgumentClause())?
    | (ExternalParameterName())? LocalParameterName() TypeAnnotation()
    | (ExternalParameterName())? LocalParameterName() TypeAnnotation() <THREE_DOTS>
}

void ExternalParameterName(): {}
{
    Identifier()
}

void LocalParameterName(): {}
{
    Identifier()
}

void DefaultArgumentClause(): {}
{
    <ASSIGN> Expression()
}


/* ===================================================================
                        5.9. GRAMMAR OF AN ENUMERATION DECLARATION
   =================================================================== */
void EnumDeclaration(): {}
{
    (Attributes())? (AccessLevelModifier())? UnionStyleEnum()
    | (Attributes())? (AccessLevelModifier())? RawValueStyleEnum()
}


void UnionStyleEnum(): {}
{
    (<INDIRECT>)? <ENUM> EnumName() (GenericParameterClause())? (TypeInheritanceClause())? (GenericWhereClause())? <OPEN_BRACKET> (UnionStyleEnumMembers())? <CLOSED_BRACKET>
}

void UnionStyleEnumMembers(): {}
{
    UnionStyleEnumMember() (UnionStyleEnumMembers())?
}

void UnionStyleEnumMember(): {}
{
    Declaration()
    | UnionStyleEnumCaseClause()
    | CompilerControlStatement()
}

void UnionStyleEnumCaseClause(): {}
{
    (Attributes())? (<INDIRECT>)? <CASE> UnionStyleEnumCaseList()
}

void UnionStyleEnumCaseList(): {}
{
    UnionStyleEnumCase()
    | UnionStyleEnumCase() <COMMA> UnionStyleEnumCaseList()
}

void UnionStyleEnumCase(): {}
{
    EnumCaseName() (TupleType())?
}

void EnumName(): {}
{
    Identifier()
}

void EnumCaseName(): {}
{
    Identifier()
}


void RawValueStyleEnum(): {}
{
    <ENUM> EnumName() (GenericParameterClause())? TypeInheritanceClause() (GenericWhereClause())? <OPEN_BRACKET> RawValueStyleEnumMembers() <CLOSED_BRACKET>
}

void RawValueStyleEnumMembers(): {}
{
    RawValueStyleEnumMember() (RawValueStyleEnumMembers())?
}

void RawValueStyleEnumMember(): {}
{
    Declaration()
    | RawValueStyleEnumCaseClause()
    | CompilerControlStatement()
}

void RawValueStyleEnumCaseClause(): {}
{
    (Attributes())? <CASE> RawValueStyleEnumCaseList()
}

void RawValueStyleEnumCaseList(): {}
{
    RawValueStyleEnumCase()
    | RawValueStyleEnumCase() <COMMA> RawValueStyleEnumCaseList()
}

void RawValueStyleEnumCase(): {}
{
    EnumCaseName() (RawValueAssignment())?
}

void RawValueAssignment(): {}
{
    <ASSIGN> RawValueLiteral()
}

void RawValueLiteral(): {}
{
    NumericLiteral()
    | StaticStringLiteral()
    | BooleanLiteral()
}


/* ===================================================================
                        5.10. GRAMMAR OF A STRUCTURE DECLARATION
   =================================================================== */
void StructDeclaration(): {}
{
    (Attributes())? (AccessLevelModifier())? <STRUCT> StructName() (GenericParameterClause())? (TypeInheritanceClause())? (GenericWhereClause())? StructBody()
}

void StructName(): {}
{
    Identifier()
}

void StructBody(): {}
{
    <OPEN_BRACKET> (StructMembers())? <CLOSED_BRACKET>
}


void StructMembers(): {}
{
    StructMember() (StructMembers())?
}

void StructMember(): {}
{
    Declaration()
    | CompilerControlStatement()
}


/* ===================================================================
                        5.11. GRAMMAR OF A CLASS DECLARATION
   =================================================================== */
void ClassDeclaration(): {}
{
    (Attributes())? (AccessLevelModifier())? (<FINAL>)? <CLASS> ClassName() (GenericParameterClause())? (TypeInheritanceClause())? (GenericWhereClause())? ClassBody()
    | (Attributes())? <FINAL> (AccessLevelModifier())? <CLASS> ClassName() (GenericParameterClause())? (TypeInheritanceClause())? (GenericWhereClause())? ClassBody()
}

void ClassName(): {}
{
    Identifier()
}

void ClassBody(): {}
{
    <OPEN_BRACKET> (ClassMembers())? <CLOSED_BRACKET>
}


void ClassMembers(): {}
{
    ClassMember() (ClassMembers())?
}

void ClassMember(): {}
{
    Declaration()
    | CompilerControlStatement()
}


/* ===================================================================
                        5.12. GRAMMAR OF A PROTOCOL DECLARATION
   =================================================================== */
void ProtocolDeclaration(): {}
{
    (Attributes())? (AccessLevelModifier())? <PROTOCOL> ProtocolName() (TypeInheritanceClause())? ProtocolBody()
}

void ProtocolName(): {}
{
    Identifier()
}

void ProtocolBody(): {}
{
    <OPEN_BRACKET> (ProtocolMembers())? <CLOSED_BRACKET>
}


void ProtocolMembers(): {}
{
    ProtocolMember() (ProtocolMembers())?
}

void ProtocolMember(): {}
{
    ProtocolMemberDeclaration()
    | CompilerControlStatement()
}


void ProtocolMemberDeclaration(): {}
{
    ProtocolPropertyDeclaration()
    | ProtocolMethodDeclaration()
    | ProtocolInitializerDeclaration()
    | ProtocolSubscriptDeclaration()
    | ProtocolAssociatedTypeDeclaration()
    | TypealiasDeclaration()
}


/* ===================================================================
                        5.13. GRAMMAR OF A PROTOCOL PROPERTY DECLARATION
   =================================================================== */
void ProtocolPropertyDeclaration(): {}
{
    VariableDeclarationHead() VariableName() TypeAnnotation() GetterSetterKeywordBlock()
}


/* ===================================================================
                        5.14. GRAMMAR OF A PROTOCOL METHOD DECLARATION
   =================================================================== */
void ProtocolMethodDeclaration(): {}
{
    FunctionHead() FunctionName() (GenericParameterClause())? FunctionSignature() (GenericWhereClause())?
}


/* ===================================================================
                        5.15. GRAMMAR OF A PROTOCOL INITIALIZER DECLARATION
   =================================================================== */
void ProtocolInitializerDeclaration(): {}
{
    InitializerHead() (GenericParameterClause())? ParameterClause() (<THROWS>)? (GenericWhereClause())?
    | InitializerHead() (GenericParameterClause())? ParameterClause() <RETHROWS> (GenericWhereClause())?
}


/* ===================================================================
                        5.16. GRAMMAR OF A PROTOCOL SUBSCRIPT DECLARATION
   =================================================================== */
void ProtocolSubscriptDeclaration(): {}
{
    SubscriptHead() SubscriptResult() GetterSetterKeywordBlock()
}


/* ===================================================================
                        5.17. GRAMMAR OF A PROTOCOL ASSOCIATED DECLARATION
   =================================================================== */
void ProtocolAssociatedTypeDeclaration(): {}
{
    (Attributes())? (AccessLevelModifier())? <ASSOCIATED_TYPE> TypealiasName() (TypeInheritanceClause())? (TypealiasAssignment())?
}


/* ===================================================================
                        5.18. GRAMMAR OF AN INITIALIZER DECLARATION
   =================================================================== */
void InitializerDeclaration(): {}
{
    InitializerHead() (GenericParameterClause())? ParameterClause() (<THROWS>)? (GenericWhereClause())? InitializerBody()
    | InitializerHead() (GenericParameterClause())? ParameterClause() <RETHROWS> (GenericWhereClause())? InitializerBody()
}

void InitializerHead(): {}
{
    (Attributes())? (DeclarationModifiers())? <INIT>
    | (Attributes())? (DeclarationModifiers())? <INIT> <QUESTION_MARK>
    | (Attributes())? (DeclarationModifiers())? <INIT> <EXCLAMATION_MARK>
}

void InitializerBody(): {}
{
    CodeBlock()
}


/* ===================================================================
                        5.19. GRAMMAR OF A DEINITIALIZER DECLARATION
   =================================================================== */
void DeinitializerDeclaration(): {}
{
    (Attributes())? <DEINIT> CodeBlock()
}


/* ===================================================================
                        5.20. GRAMMAR OF AN EXTENSION DECLARATION
   =================================================================== */
void ExtensionDeclaration(): {}
{
    (Attributes())? (AccessLevelModifier())? <EXTENSION> TypeIdentifier() (TypeInheritanceClause())? ExtensionBody()
    | (Attributes())? (AccessLevelModifier())? <EXTENSION> TypeIdentifier() GenericWhereClause() ExtensionBody()
}

void ExtensionBody(): {}
{
    <OPEN_BRACKET> (ExtensionMembers())? <CLOSED_BRACKET>
}


void ExtensionMembers(): {}
{
    ExtensionMember() (ExtensionMembers())?
}

void ExtensionMember(): {}
{
    Declaration()
    | CompilerControlStatement()
}



/* ===================================================================
                        5.21. GRAMMAR OF A SUBSCRIPT DECLARATION
   =================================================================== */
void SubscriptDeclaration(): {}
{
    SubscriptHead() SubscriptResult() CodeBlock()
    | SubscriptHead() SubscriptResult() GetterSetterBlock()
    | SubscriptHead() SubscriptResult() GetterSetterKeywordBlock()
}

void SubscriptHead(): {}
{
    (Attributes())? (DeclarationModifiers())? <SUBSCRIPT> ParameterClause()
}

void SubscriptResult(): {}
{
    <ARROW_RIGHT> (Attributes())? Type()
}


/* ===================================================================
                        5.22. GRAMMAR OF AN OPERATOR DECLARATION
   =================================================================== */



/* ===================================================================
                        5.23. GRAMMAR OF A PRECEDENCE GROUP DECLARATION
   =================================================================== */



/* ===================================================================
                        5.24. GRAMMAR OF A DECLARATION MODIFIER
   =================================================================== */




/* =====================================================================================================================
                        6. Attributes
   ================================================================================================================== */


/* ===================================================================
                        6.1. GRAMMAR OF AN ATTRIBUTE
   =================================================================== */

void Attribute(): {}
{
    <AT> AttributeName() (AttributeArgumentClause())?
}

void AttributeName(): {}
{
    Identifier()
}

void AttributeArgumentClause(): {}
{
    <OPEN_PARENTHESIS> (BalancedTokens())? <CLOSE_PARENTHESIS>
}

void Attributes(): {}
{
    Attribute() (Attributes())?
}

void BalancedTokens(): {}
{
    BalancedToken() (BalancedTokens())?
}

void BalancedToken(): {}
{
    <OPEN_PARENTHESIS> (BalancedTokens())? <CLOSE_PARENTHESIS>
    | <OPEN_SQUARE_BRACKET> (BalancedTokens())? <CLOSE_SQUARE_BRACKET>
    | <OPEN_BRACKET> (BalancedTokens())? <CLOSED_BRACKET>
    // TODO: Доделать

}

/* =====================================================================================================================
                        7. Patterns (DONE)
   ================================================================================================================== */

/* ===================================================================
                        7.1. GRAMMAR OF A PATTERN (DONE)
   =================================================================== */

void Pattern(): {}
{
    WildcardPattern() (TypeAnnotation())?
    | IdentifierPattern() (TypeAnnotation())?
    | ValueBindingPattern()
    | TuplePattern() (TypeAnnotation())?
    | EnumCasePattern()
    | OptionalPattern()
    | TypeCastingPattern()
    | ExpressionPattern()
}

/* ===================================================================
                        7.2. GRAMMAR OF A WILDCARD PATTERN (DONE)
   =================================================================== */

void WildcardPattern(): {}
{
    <UNDERSCORE>
}

/* ===================================================================
                        7.3. GRAMMAR OF AN IDENTIFIER PATTERN (DONE)
   =================================================================== */

void IdentifierPattern(): {}
{
    Identifier()
}

/* ===================================================================
                        7.4. GRAMMAR OF A VALUE-BINDING PATTERN (DONE)
   =================================================================== */

void ValueBindingPattern(): {}
{
    <VAR> Pattern()
    | <LET> Pattern()
}

/* ===================================================================
                        7.5 GRAMMAR OF A TUPLE PATTERN (DONE)
   =================================================================== */

void TuplePattern(): {}
{
    <OPEN_PARENTHESIS> (TuplePatternElementList())? <CLOSED_PARENTHESIS>
}

void TuplePatternElementList(): {}
{
    TuplePatternElement()
    | TuplePatternElement() <COMMA> TupleTypeElementList()
}

void TuplePatternElement(): {}
{
    Pattern()
    | Identifier() <COLON> Pattern()
}

/* ===================================================================
                        7.6. GRAMMAR OF AN ENUMERATION CASE PATTERN (DONE)
   =================================================================== */

void EnumCasePattern(): {}
{
    (TypeIdentifier())? <DOT> EnumCaseName() (TuplePattern())?
}

/* ===================================================================
                        7.7. GRAMMAR OF AN OPTIONAL PATTERN (DONE)
   =================================================================== */

void OptionalPattern(): {}
{
    IdentifierPattern() <QUESTION_MARK>
}


/* ===================================================================
                        7.8. GRAMMAR OF A TYPE CASTING PATTERN (DONE)
   =================================================================== */

void TypeCastingPattern(): {}
{
    IsPattern()
    | AsPattern()
}

void IsPattern(): {}
{
    <IS> Type()
}

void AsPattern(): {}
{
    Pattern() <AS> Type()
}

/* ===================================================================
                        7.9. GRAMMAR OF AN EXPRESSION PATTERN (DONE)
   =================================================================== */

void ExpressionPattern(): {}
{
    Expression()
}


/* =====================================================================================================================
                        8. Generic Parameters and Arguments
   ================================================================================================================== */


/* ===================================================================
                        8.1. GRAMMAR OF A GENERIC PARAMETER CLAUSE
   =================================================================== */
void GenericParameterClause(): {}
{
    <OPEN_TRIANGULAR_BRACKET> GenericParameterList() <CLOSED_TRIANGULAR_BRACKET>
}

void GenericParameterList(): {}
{
    GenericParameter()
    | GenericParameter() <COMMA> GenericParameterList()
}

void GenericParameter(): {}
{
    TypeName()
    | TypeName() <COLON> TypeIdentifier()
    | TypeName() <COLON> ProtocolCompositionType()
}

void GenericWhereClause(): {}
{
    <WHERE> RequirementList()
}

void RequirementList(): {}
{
    Requirement()
    | Requirement() <COMMA> RequirementList()
}

void Requirement(): {}
{
    ConformanceRequirement()
    | SameTypeRequirement()
}

void ConformanceRequirement(): {}
{
    TypeIdentifier() <COLON> TypeIdentifier()
    | TypeIdentifier() <COLON> ProtocolCompositionType()
}

void SameTypeRequirement(): {}
{
    TypeIdentifier() <EQUALS> Type()
}


/* ===================================================================
                        8.2. GRAMMAR OF A GENERIC ARGUMENT CLAUSE
   =================================================================== */

void GenericArgumentClause(): {}
{
    <OPEN_TRIANGULAR_BRACKET> GenericArgumentList() <CLOSED_TRIANGULAR_BRACKET>
}

void GenericArgumentList(): {}
{
    GenericArgument()
    | GenericArgument() <COMMA> GenericArgumentList()
}

void GenericArgument(): {}
{
    Type()
}