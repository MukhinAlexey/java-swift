options
{
     LOOKAHEAD=2;
}

PARSER_BEGIN(JavaSwift)

public class JavaSwift
{
    public static void main(String args[]) throws ParseException
    {
        JavaSwift parser = new JavaSwift(System.in);
        while (true)
        {
            parser.parseOneLine();
        }
    }
}

PARSER_END(JavaSwift)

TOKEN:
{

    < UPPER_LETTER: ["A"-"Z"] >
    | < LOWER_LETTER: ["a"-"z"] >
    | < UNDERSCORE: "_" >
    | < EXTENDED_UNICODE: ("U+00A8") | ("U+00AA") | ("U+00AD") | ("U+00AF") | (["U+00B2"-"U+00B5"]) | (["U+00B7"-"U+00BA"]) >
    | < EXTENDED_UNICODE: (["U+00BC"-"U+00BE"]) | (["U+00C0"-"U+00D6"]) | (["U+00D8"-"U+00F6"]) | (["U+00F8"-"U+00FF"]) >
    | < EXTENDED_UNICODE: (["U+0100"-"U+02FF"]) | (["U+0370"-"U+167F"]) | (["U+1681"-"U+180D"]) | (["U+180F"-"U+1DBF"]) >
    | < EXTENDED_UNICODE: (["U+1E00"-"U+1FFF"]) >
    | < EXTENDED_UNICODE: (["U+200B"-"U+200D"]) | (["U+202A"-"U+202E"]) | (["U+203F"-"U+2040"]) | ("U+2054") | (["U+2060"-"U+206F"]) >
    | < EXTENDED_UNICODE: (["U+2070"-"U+20CF"]) | (["U+2100"-"U+218F"]) | (["U+2460"-"U+24FF"]) | (["U+2776"-"U+2793"]) >
    | < EXTENDED_UNICODE: (["U+2C00"-"U+2DFF "]) | (["U+2E80"-"U+2FFF"]) >
    | < EXTENDED_UNICODE: (["U+3004"-"U+3007"]) | (["U+3021"-"U+302F"]) | (["U+3031"-"U+303F"]) | (["U+3040"-"U+D7FF"]) >
    | < EXTENDED_UNICODE: (["U+F900"-"U+FD3D"]) | (["U+FD40"-"U+FDCF"]) | (["U+FDF0"-"U+FE1F"]) | (["U+FE30"-"U+FE44"]) >
    | < EXTENDED_UNICODE: (["U+FE47"-"U+FFFD"]) >
    | < EXTENDED_UNICODE: (["U+10000"-"U+1FFFD"]) | (["U+20000"-"U+2FFFD"]) | (["U+30000"-"U+3FFFD"]) | (["U+40000"-"U+4FFFD"]) >
    | < EXTENDED_UNICODE: (["U+50000"-"U+5FFFD"]) | (["U+60000"-"U+6FFFD"]) | (["U+70000"-"U+7FFFD"]) | (["U+80000"-"U+8FFFD"]) >
    | < EXTENDED_UNICODE: (["U+90000"-"U+9FFFD"]) | (["U+A0000"-"U+AFFFD"]) | (["U+B0000"-"U+BFFFD"]) | (["U+C0000"-"U+CFFFD"]) >
    | < EXTENDED_UNICODE: (["U+D0000"-"U+DFFFD "]) | (["U+E0000"-"U+EFFFD"]) >
    | < EXTENDED_UNICODE: (["U+0300"-"U+036F "]) | (["U+1DC0"-"U+1DFF"]) | (["U+20D0"-"U+20FF"]) | (["U+FE20"-"U+FE2F"]) >

    | < ESCAPE_CHARACTERS: ("\0") | ("\\") | ("\t") | ("\n") | ("\r") | ("\"")  | ("\'") >
    | < ESCAPE_CHARACTERS: ("\\u") (<OPEN_BRACKET>) ("Between one and eight hexadecimal digits") (<CLOSED_BRACKET>) >

    /* ================================
                    Digits
       ================================ */
    | < DIGIT: ["0"-"9"]>

    | < BINARY_DIGIT_BEGIN: "0b">
    | < BINARY_DIGIT: ["0"-"1"] >

    | < OCTAL_DIGIT_BEGIN: "0o">
    | < OCTAL_DIGIT: ["0"-"7"] >
    | < DECIMAL_DIGIT: (<DIGIT>)>

    | < HEXADECIMAL_DIGIT_BEGIN: "0x">
    | < HEXADECIMAL_DIGIT: (<DECIMAL_DIGIT>) | (["a"-"f"]) | (["A"-"F"])>


    /* ================================
                    Math
       ================================ */
    | < PLUS: "+" >
    | < MINUS: "-" >
    | < ASSIGN: "=" >
    | < E: ("E") | ("e") >
    | < P: ("P") | ("p") >
    | <STAR: "*" >
    | <PERCENT: "%" >
    | <MORE_OR_EQUALS: ">=" >
    | <LESS_OR_EQUALS: "<=" >
    | <EQUALS: "==" >

    /* ================================
                    Literals
       ================================ */
    | < TRUE: "true">
    | < FALSE: "false">
    | < NIL: "nil">
    | < SHARP_FILE: "#file" >
    | < SHARP_LINE: "#line" >
    | < COLUMN: "#column" >
    | < FUNCTION: "#function" >
    | < COLOR_LITERAL: "#colorLiteral" >
    | < RED: "red" >
    | < GREEN: "green" >
    | < BLUE: "blue" >
    | < ALPHA: "alpha" >
    | < FILTER_LITERAL: "#fileLiteral" >
    | < IMAGE_LITERAL: "#imageLiteral" >
    | < RESOURCE_NAME: "resourceName" >


    /* ================================
                    Operators
       ================================ */
    | < OPERATOR_HEAD: (["U+00A1"-"U+00A7"]) >
    | < OPERATOR_HEAD: ("U+00A9") | ("U+00AB") >
    | < OPERATOR_HEAD: ("U+00AC ") | ("U+00AE") >
    | < OPERATOR_HEAD: (["U+00B0"-"U+00B1"]) | ("U+00B6 ") | ("U+00BB") | ("U+00BF ") | ("U+00D7") | ("U+00F7") >
    | < OPERATOR_HEAD: (["U+2016"-"U+2017 "]) | (["U+2020"-"U+2027 "]) >
    | < OPERATOR_HEAD: (["U+2030"-"U+203E"]) >
    | < OPERATOR_HEAD: (["U+2041"-"U+2053"]) >
    | < OPERATOR_HEAD: (["U+2055"-"U+205E"]) >
    | < OPERATOR_HEAD: (["U+2190"-"U+23FF"]) >
    | < OPERATOR_HEAD: (["U+2500"-"U+2775"]) >
    | < OPERATOR_HEAD: (["U+2794"-"U+2BFF"]) >
    | < OPERATOR_HEAD: (["U+2E00"-"U+2E7F"]) >
    | < OPERATOR_HEAD: (["U+3001"-"U+3003"]) >
    | < OPERATOR_HEAD: (["U+3008"-"U+3030"]) >

    | < OPERATOR_CHARACTER: (["U+0300"-"U+036F"]) >
    | < OPERATOR_CHARACTER: (["U+1DC0"-"U+1DFF"]) >
    | < OPERATOR_CHARACTER: (["U+20D0"-"U+20FF"]) >
    | < OPERATOR_CHARACTER: (["U+FE00"-"U+FE0F"]) >
    | < OPERATOR_CHARACTER: (["U+FE20"-"U+FE2F"]) >
    | < OPERATOR_CHARACTER: (["U+E0100"-"U+E01EF"]) >


    /* ================================
                    Types
       ================================ */
    | < ANY: "any" >
    | < ARROW_RIGHT: "->">


    /* ================================
                    Annotation
       ================================ */
    | < INOUT: "inout" >


    /* ================================
                    Annotation
       ================================ */
    | < THROWS: "throws">
    | < RETHROWS: "rethrows">


    /* ================================
                    Metatype
       ================================ */
    | < CAPITAL_TYPE: "Type" >
    | < CAPITAL_PROTOCOL: "Protocol">


    /* ================================
                    Type Inheritance
       ================================ */
    | < CLASS: "class" >


    /* ================================
                    Try
       ================================ */
    | < TRY: "try" >


    /* ================================
                    Type-Casting
       ================================ */
    | < AS: "as" >
    | < IS: "is" >

    /* ================================
                    Self
       ================================ */
    | < SELF: "self" >
    | < INIT: "init" >


    /* ================================
                    Superclass
       ================================ */
    | < SUPER: "super" >


    /* ================================
                    Closure
       ================================ */
    | < IN: "in" >
    | < WEAK: "weak" >
    | < UNOWNED: "unowned" >
    | < SAFE: "safe" >
    | < UNSAFE: "unsafe" >


    /* ================================
                    Selector
       ================================ */
    | < SELECTOR: "#selector" >
    | < GETTER: "getter" >
    | < SETTER: "setter" >


    /* ================================
                    Key-Path
       ================================ */
    | < KEY_PATH: "#keyPath" >


    /* ================================
                    Dynamic Type
       ================================ */
    | < TYPE: "type" >
    | < OF: "of" >


    /* ================================
                    Dynamic Type
       ================================ */
    | < LET: "let" >
    | < VAR: "var" >


    /* ================================
                    Loops
       ================================ */
    | < WHILE: "while" >
    | < FOR: "for" >
    | < CASE: "case" >
    | < REPEAT: "repeat" >
    | < BREAK: "break" >
    | < CONTINUE: "continue" >


    /* ================================
                    Conditions
       ================================ */
    | < IF: "if" >
    | < ELSE: "else" >
    | < SWITCH: "switch" >
    | < DEFAULT: "default" >
    | < WHERE: "where" >


    /* ================================
                    Guard
       ================================ */
    | < GUARD: "guard" >


    /* ================================
                    Fallthrough
       ================================ */
    | < FALLTHROUGH: "fallthrough" >
    
    
    /* ================================
                    Return
       ================================ */
    | < RETURN: "return" >
    
    
    /* ================================
                    Throw
       ================================ */
    | < Throw: "throw" >
    
    
    /* ================================
                    Defer
       ================================ */
    | < DEFER: "defer" >
    
    
    /* ================================
                    Do
       ================================ */
    | < DO: "do" >
    | < CATCH: "catch" >
    
    
    /* ================================
                    Conditional Compilation
       ================================ */
    | < SHARP_IF: "#if" >
    | < SHARP_ELSEIF: "#elseif" >
    | < SHARP_ELSE: "#else" >
    | < SHARP_ENDIF: "#endif" >
    | < OS: "os" >
    | < ARCH: "arch" >
    | < SWIFT: "swift" >
    | < MAC_OS: "macOS" >
    | < IOS: "iOS" >
    | < WATCH_OS: "watchOS" >
    | < TV_OS: "tvOS" >
    | < I_386: "i386" >
    | < X_86_64: "x86_64" >
    | < ARM: "arm" >
    | < ARM_64: "arm64" >
    
    
    /* ================================
                    Line Control
       ================================ */
    | < SOURCE_LOCATION: "#sourceLocation" >
    | < FILE: "file" >
    | < LINE: "line" >


    /* ================================
                    Availability
       ================================ */
    | < SHARP_AVAILABLE: "#available" >
    | < IOS_APP_EXT: "iOSApplicationExtension" >
    | < MAC_OS_APP_EXT: "macOSApplicationExtension" >


    /* ================================
                    Import
       ================================ */
    | < IMPORT: "import" >
    | < TYPE_ALIAS: "typealias" >
    | < ENUM: "enum" >
    | < PROTOCOL: "protocol" >
    | < FUNC: "func" >


    /* ================================
                    Variable
       ================================ */
    | < GET: "get" >
    | < SET: "set" >
    | < WILL_SET: "willSet" >
    | < DID_SET: "didSet" >


    /* ================================
                    Enumeration
       ================================ */
    | < INDIRECT: "indirect" >


    /* ================================
                    Structure
       ================================ */
    | < STRUCT: "struct" >


    /* ================================
                    Class
       ================================ */
    | < FINAL: "final" >


    /* ================================
                    Associated Type
       ================================ */
    | < ASSOCIATED_TYPE: "associatedtype" >


    /* ================================
                    Deinitializer
       ================================ */
    | < DEINIT: "deinit" >


    /* ================================
                    Extension
       ================================ */
    | < EXTENSION: "extension" >


    /* ================================
                    Subscript
       ================================ */
    | < SUBSCRIPT: "subscript" >


    /* ================================
                    Operators
       ================================ */
    | < PREFIX: "prefix" >
    | < POSTFIX: "postfix" >
    | < INFIX: "infix" >
    | < OPERATOR: "operator" >


    /* ================================
                    Precedence Group
       ================================ */
    | < PRECEDENCE_GROUP: "precedencegroup" >
    | < HIGHER_THAN: "higherThan" >
    | < LOWER_THAN: "lowerThan" >
    | < ASSIGNMENT: "assignment" >
    | < ASSOCIATIVITY: "associativity" >
    | < LEFT: "left" >
    | < RIGHT: "right" >
    | < NONE: "none" >


    /* ================================
                    Declaration
       ================================ */
    | < CONVENIENCE: "convenience" >
    | < DYNAMIC: "dynamic" >
    | < INFIX: "infix" >
    | < LAZY: "lazy" >
    | < OPTIONAL: "optional" >
    | < OVERRIDE: "override" >
    | < POSTFIX: "postfix" >
    | < PREFIX: "prefix" >
    | < REQUIRED: "required" >
    | < STATIC: "static" >
    | < PRIVATE: "private" >
    | < FILEPRIVATE: "fileprivate"  >
    | < INTERNAL: "internal" >
    | < PUBLIC: "public" >
    | < OPEN: "open" >
    | < MUTATING: "mutating" >
    | < NON_MUTATING: "nonmutating" >


    /* ================================
                    Punctuation
       ================================ */
    | < DOT: "." >
    | < THREE_DOTS: "...">
    | < COMMA: "," >
    | < SEMICOLON: ";" >
    | < COLON: ":" >
    | < QUESTION_MARK: "?" >
    | < EXCLAMATION_MARK: "!" >
    | < SLASH: "/" >
    | < BACK_SLASH: "\\" >
    | < DOLLAR: "$" >
    | < AMPERSAND: "&" >
    | < DBL_AMPERSAND: "&&" >
    | < DBL_OR: "||" >
    | < AT: "@" >


    /* ================================
                    Brackets
       ================================ */
    | < OPEN_BRACKET: "{" >
    | < CLOSED_BRACKET: "}" >
    | < OPEN_SQUARE_BRACKET: "[" >
    | < CLOSED_SQUARE_BRACKET: "]" >
    | < OPEN_DOUBLE_QUOTE: "\"" >
    | < CLOSED_DOUBLE_QUOTE: "\"" >
    | < OPEN_PARENTHESIS: "(" >
    | < CLOSED_PARENTHESIS: ")" >
    | < OPEN_QUOTE: "`" >
    | < CLOSED_QUOTE: "`" >
    | < OPEN_TRIANGULAR_BRACKET: "<" >
    | < CLOSED_TRIANGULAR_BRACKET: ">" >



    | < EOL: "\n" >
}








/* =====================================================================================================================
                        1. Lexical Structure
   ================================================================================================================== */

/* ===================================================================
                        1.1. GRAMMAR OF AN IDENTIFIER
   =================================================================== */

void Identifier(): {}
{
    IdentifierHead() (IdentifierCharacter())?
    | <OPEN_QUOTE> IdentifierHead() (IdentifierCharacter())? <CLOSED_QUOTE>
    | ImplicitParameterName()
}

void IdentifierHead(): {}
{
    // TODO: Доделать и разобраться
    <UPPER_LETTER> |
    <LOWER_LETTER> |
    <UNDERSCORE> |
    <EXTENDED_UNICODE>
}

void IdentifierCharacter(): {}
{
    <DIGIT>
    | IdentifierHead()
}

void IdentifierCharacters(): {}
{
    IdentifierCharacter() (IdentifierCharacters())?
}

void ImplicitParameterName(): {}
{
    <DOLLAR> <DECIMAL_DIGIT>
}

/* ===================================================================
                        1.2. GRAMMAR OF A LITERAL
   =================================================================== */

void Literal(): {}
{
    NumericLiteral()
    | StringLiteral()
    | BooleanLiteral()
    | NilLiteral()
}

void NumericLiteral(): {}
{
    (<MINUS>)? IntegerLiteral()
    | (<MINUS>)? FloatingPointLiteral()
}

void BooleanLiteral(): {}
{
    <TRUE>
    | <FAlSE>
}

void NilLiteral(): {}
{
    <NIL>
}

/* ===================================================================
                        1.3. GRAMMAR OF AN INTEGER LITERAL
   =================================================================== */

void IntegerLiteral(): {}
{
    BinaryLiteral()
    | OctalLiteral()
    | DecimalLiteral()
    | HexadecimalLiteral()
}

void BinaryLiteral(): {}
{
    <BINARY_DIGIT_BEGIN> <BINARY_DIGIT> (BinaryLiteralCharacter())?
}


void BinaryLiteralCharacter(): {}
{
    <BINARY_DIGIT>
    | <UNDERSCORE>
}

void OctalLiteral(): {}
{
    <OCTAL_DIGIT_BEGIN> <OCTAL_DIGIT> (OctalLiteralCharacters())?
}

void OctalLiteralCharacter(): {}
{
    <OCTAL_DIGIT>
    | <UNDERSCORE>
}

void OctalLiteralCharacters(): {}
{
    OctalLiteralCharacter() (OctalLiteralCharacters())?
}

void DecimalLiteral(): {}
{
    <DECIMAL_DIGIT> (DecimalLiteralCharacter())?
}

void DecimalDigits(): {}
{
    <DECIMAL_DIGIT> (DecimalDigits())?
}

void DecimalLiteralCharacter(): {}
{
    <DECIMAL_DIGIT>
    | <UNDERSCORE>
}

void DecimalLiteralCharacters(): {}
{
    DecimalLiteralCharacter() (DecimalLiteralCharacters())?
}

void HexadecimalLiteral(): {}
{
    <HEXADECIMAL_DIGIT_BEGIN> <HEXADECIMAL_DIGIT> (HexadecimalLiteralCharacters())?
}

void HexadecimalLiteralCharacter(): {}
{
    <HEXADECIMAL_DIGIT>
    | <UNDERSCORE>
}

void HexadecimalLiteralCharacters(): {}
{
    HexadecimalLiteralCharacter() (HexadecimalLiteralCharacters())?
}

/* ===================================================================
                        1.4. GRAMMAR OF A FLOATING-POINT LITERAL
   =================================================================== */

void FloatingPointLiteral(): {}
{
    DecimalLiteral() (DecimalFraction())? (DecimalExponent())?
}

void DecimalFraction(): {}
{
    <DOT> DecimalLiteral()
}

void DecimalExponent(): {}
{
    <E> (<PLUS>)? DecimalLiteral()
    | <E> (<MINUS>)? DecimalLiteral()
}

void HexadecimalFraction(): {}
{
    <DOT> <HEXADECIMAL_DIGIT>
    | <DOT> <HEXADECIMAL_DIGIT> HexadecimalLiteralCharacters()
}

void HexadecimalExponent(): {}
{
    <P> (<PLUS>)? DecimalLiteral()
    | <P> (<MINUS>)? DecimalLiteral()
}

/* ===================================================================
                        1.5. GRAMMAR OF A STRING LITERAL
   =================================================================== */

void StringLiteral(): {}
{
    StaticStringLiteral()
    | InterpolatedStringLiteral()
}

void StaticStringLiteral(): {}
{
    <OPEN_DOUBLE_QUOTE> (QuotedText())? <CLOSED_DOUBLE_QUOTE>
}

void QuotedText(): {}
{
    QuotedTextItem() (QuotedText())?
}

void QuotedTextItem(): {}
{
    <ESCAPE_CHARACTERS>
    // TODO Any Unicode scalar value except "­, \­, U+000A, or U+000D
}

void InterpolatedStringLiteral(): {}
{
    <OPEN_DOUBLE_QUOTE> (InterpolatedText())? <CLOSED_DOUBLE_QUOTE>
}

void InterpolatedText(): {}
{
    InterpolatedTextItem() (InterpolatedText())?
}

void InterpolatedTextItem(): {}
{
    <BACK_SLASH> <OPEN_PARENTHESIS> Expression() <CLOSED_PARENTHESIS>
    | QuotedTextItem()
}

/* ===================================================================
                        1.6. GRAMMAR OF OPERATORS
   =================================================================== */
// TODO: Доделать весь раздел

void Operator(): {}
{
    // TODO: Доделать
    <NIL>
}

void OperatorHead(): {}
{
    // TODO: Доделать
    <NIL>
}

void OperatorCharacter(): {}
{
    // TODO: Доделать
    <NIL>
}

void OperatorCharacters(): {}
{
    OperatorCharacter() (OperatorCharacters())?
}


/* =====================================================================================================================
                        2. Lexical Structure
   ================================================================================================================== */

/* ===================================================================
                        2.1. GRAMMAR OF A TYPE
   =================================================================== */

void Type(): {}
{
    ArrayType()
    | DictionaryType()
    | FunctionType()
    | TypeIdentifier()
    | TupleType()
    | OptionalType()
    | ImplicitlyUnwrappedOptionalType()
    | ProtocolCompositionType()
    | MetatypeType()
    | <ANY>
    | <SELF>
}

/* ===================================================================
                        2.2. GRAMMAR OF A TYPE ANNOTATION
   =================================================================== */

void TypeAnnotation(): {}
{
    <COLON> (Attributes())? (<INOUT>)? Type()
}

/* ===================================================================
                        2.3. GRAMMAR OF A TYPE IDENTIFIER
   =================================================================== */

void TypeIdentifier(): {}
{
    TypeName() (GenericArgumentClause())?
    | TypeName() (GenericArgumentClause())? <DOT> TypeIdentifier()
}

void TypeName(): {
}
{
    Identifier()
}

/* ===================================================================
                        2.4. GRAMMAR OF A TUPLE TYPE
   =================================================================== */

void TupleType(): {}
{
    <OPEN_PARENTHESIS> (TupleTypeElementList())? <CLOSED_PARENTHESIS>
}

void TupleTypeElementList(): {}
{
    TupleTypeElement() |
    TupleTypeElement() <COMMA> TupleTypeElementList()
}

void TupleTypeElement(): {}
{
    ElementName() TypeAnnotation()| Type()
}

void ElementName(): {}
{
    Identifier()
}

/* ===================================================================
                        2.5. GRAMMAR OF A FUNCTION TYPE
   =================================================================== */

void FunctionType(): {}
{
    (Attributes())? FunctionTypeArgumentClause() (<THROWS>)? <ARROW_RIGHT> Type() |
    (Attributes())? FunctionTypeArgumentClause() <RETHROWS> <ARROW_RIGHT> Type()
}

void FunctionTypeArgumentClause(): {}
{
    <OPEN_PARENTHESIS> <CLOSED_PARENTHESIS> |
    <OPEN_PARENTHESIS> FunctionTypeArgumentList() <CLOSED_PARENTHESIS> (<THREE_DOTS>)?
}

void FunctionTypeArgumentList(): {}
{
    FunctionTypeArgument() |
    FunctionTypeArgument() <COMMA> FunctionTypeArgumentList()
}

void FunctionTypeArgument(): {}
{
    (Attributes())? (<INOUT>)? Type() |
    ArgumentLabel() TypeAnnotation()
}

void ArgumentLabel(): {}
{
    Identifier()
}

/* ===================================================================
                        2.6. GRAMMAR OF AN ARRAY TYPE
   =================================================================== */

void ArrayType(): {}
{
    <OPEN_SQUARE_BRACKET> Type() <CLOSED_SQUARE_BRACKET>
}

/* ===================================================================
                        2.7. GRAMMAR OF A DICTIONARY TYPE
   =================================================================== */

void DictionaryType(): {}
{
    <OPEN_SQUARE_BRACKET> Type() <COLON> Type() <CLOSED_SQUARE_BRACKET>
}

/* ===================================================================
                        2.8. GRAMMAR OF AN OPTIONAL TYPE
   =================================================================== */

void OptionalType(): {}
{
    Type() <QUESTION_MARK>
}

/* ===================================================================
                        2.9. GRAMMAR OF AN IMPLICITLY UNWRAPPED OPTIONAL TYPE
   =================================================================== */

void ImplicitlyUnwrappedOptionalType(): {}
{
    Type() <EXCLAMATION_MARK>
}

/* ===================================================================
                        2.10. GRAMMAR OF A PROTOCOL COMPOSITION TYPE
   =================================================================== */

void ProtocolCompositionType(): {}
{
    ProtocolIdentifier() <AMPERSAND> ProtocolCompositionContinuation()
}

void ProtocolCompositionContinuation(): {}
{
    ProtocolIdentifier() ProtocolCompositionType()
}

void ProtocolIdentifier(): {}
{
    TypeIdentifier()
}

/* ===================================================================
                        2.11. GRAMMAR OF A METATYPE TYPE
   =================================================================== */

void MetatypeType(): {}
{
    Type() <DOT> <TYPE>
    | Type() <DOT> <CAPITAL_PROTOCOL>
}

/* ===================================================================
                        2.12. GRAMMAR OF A TYPE INHERITANCE CLAUSE
   =================================================================== */

void TypeInheritanceClause(): {}
{
    <COLON> <CLASS> <COMMA> TypeInheritanceList()
    | <COLON> <CLASS>
    | <COLON> TypeInheritanceList()
}

void TypeInheritanceList(): {}
{
    TypeIdentifier()
    | TypeIdentifier() <COMMA> TypeInheritanceList()
}

/* =====================================================================================================================
                        3. Expressions
   ================================================================================================================== */

/* ===================================================================
                        3.1. GRAMMAR OF AN EXPRESSION
   =================================================================== */
void Expression(): {}
{
    (<TRY>)? PrefixExpression() (BinaryExpressions())?
}

void ExpressionList(): {}
{
    Expression()
    | Expression() <COMMA> ExpressionList()
}

/* ===================================================================
                        3.2. GRAMMAR OF A PREFIX EXPRESSION
   =================================================================== */

void PrefixExpression(): {}
{
    (PrefixOperator())? PostfixExpression()
    | InOutExpression()
}

void InOutExpression(): {}
{
    <AMPERSAND> Identifier()
}

// TODO:  Grammar of a try expression

/* ===================================================================
                        3.3. GRAMMAR OF A BINARY EXPRESSION
   =================================================================== */

void BinaryExpression(): {}
{
    BinaryOperator() PrefixExpression()
    | <ASSIGN> (<TRY>)? PrefixExpression()
    | ConditionalOperator() (<TRY>)? PrefixExpression()
    | TypeCastingOperator()
}

void BinaryExpression(): {}
{
    BinaryExpression() (BinaryExpressions())?
}

/* ===================================================================
                        3.4. GRAMMAR OF A CONDITIONAL OPERATOR
   =================================================================== */

void ConditionalOperator(): {}
{
    <QUESTION_MARK> (<TRY>)? Expression() <COLON>
}

/* ===================================================================
                        3.5. GRAMMAR OF A TYPE-CASTING OPERATOR
   =================================================================== */

void TypeCastingOperator(): {}
{
    <IS> Type()
    | <AS> Type()
    | <AS> <QUESTION_MARK> Type()
    | <AS> <EXCLAMATION_MARK> Type()
}

/* ===================================================================
                        3.6. GRAMMAR OF A PRIMARY EXPRESSION
   =================================================================== */

void PrimaryExpression(): {}
{
    Identifier() (GenericArgumentClause())? |
    LiteralExpression() |
    SelfExpression() |
    SuperclassExpression() |
    ClojureExpression() |
    ParenthesizedExpression() |
    TupleExpression() |
    ImplicitMemberExpression() |
    WildcardExpression() |
    SelectorExpression()|
    KeyPathExpression()
}

/* ===================================================================
                        3.7. GRAMMAR OF A LITERAL EXPRESSION
   =================================================================== */

void LiteralExpression(): {}
{
    // TODO: Доделать
    Literal() |
    ArrayLiteral() |
    DictionaryLiteral() |
    PlaygroundLiteral()
}

/* ===================================================================
                        3.8. GRAMMAR OF A SELF EXPRESSION
   =================================================================== */



/* ===================================================================
                        3.9. GRAMMAR OF A SUPERCLASS EXPRESSION
   =================================================================== */



/* ===================================================================
                        3.10. GRAMMAR OF A CLOSURE EXPRESSION
   =================================================================== */



/* ===================================================================
                        3.11. GRAMMAR OF A IMPLICIT MEMBER EXPRESSION
   =================================================================== */



/* ===================================================================
                        3.12. GRAMMAR OF A PARENTHESIZED EXPRESSION
   =================================================================== */



/* ===================================================================
                        3.13. GRAMMAR OF A TUPLE EXPRESSION
   =================================================================== */



/* ===================================================================
                        3.14. GRAMMAR OF A WILDCARD EXPRESSION
   =================================================================== */



/* ===================================================================
                        3.15. GRAMMAR OF A SELECTOR EXPRESSION
   =================================================================== */



/* ===================================================================
                        3.16. GRAMMAR OF A KEY-PATH EXPRESSION
   =================================================================== */



/* ===================================================================
                        3.17. GRAMMAR OF A POSTFIX EXPRESSION
   =================================================================== */



/* ===================================================================
                        3.18. GRAMMAR OF A FUNCTIONAL CALL EXPRESSION
   =================================================================== */



/* ===================================================================
                        3.19. GRAMMAR OF AN INITIALIZER EXPRESSION
   =================================================================== */



/* ===================================================================
                        3.20. GRAMMAR OF AN EXPLICIT MEMBER EXPRESSION
   =================================================================== */



/* ===================================================================
                        3.21. GRAMMAR OF A SELF EXPRESSION
   =================================================================== */



/* ===================================================================
                        3.22. GRAMMAR OF A DYNAMIC TYPE EXPRESSION
   =================================================================== */



/* ===================================================================
                        3.23. GRAMMAR OF A SUBSCRIPT EXPRESSION
   =================================================================== */



/* ===================================================================
                        3.24. GRAMMAR OF A FORCED-VALUE EXPRESSION
   =================================================================== */



/* ===================================================================
                        3.25. GRAMMAR OF AN OPTIONAL-CHAINING EXPRESSION
   =================================================================== */




/* =====================================================================================================================
                        4. Statements
   ================================================================================================================== */


/* ===================================================================
                        4.1. GRAMMAR OF A STATEMENT
   =================================================================== */
void Statement(): {}
{
    Expression() (<SEMICOLON>)?
    | Declaration() (<SEMICOLON>)?
    | LoopStatement() (<SEMICOLON>)?
    | BranchStatement() (<SEMICOLON>)?
    | LabeledStatement() (<SEMICOLON>)?
    | ControlTransferStatement() (<SEMICOLON>)?
    | DeferStatement() (<SEMICOLON>)?
    | DoStatement() (<SEMICOLON>)?
    | CompilerControlStatement() (<SEMICOLON>)?
}

void Statements(): {}
{
    Statement() (Statements())?
}


/* ===================================================================
                        4.2. GRAMMAR OF A LOOP STATEMENT
   =================================================================== */
void LoopStatement(): {}
{
    ForInStatement()
    | WhileStatement()
    | RepeatWhileStatement()
}


/* ===================================================================
                        4.3. GRAMMAR OF A FOR-IN STATEMENT
   =================================================================== */
void ForInStatement(): {}
{
    <FOR> (<CASE>)? Pattern() <IN> Expression() (WhereClause())? CodeBlock()
}


/* ===================================================================
                        4.4. GRAMMAR OF A WHILE STATEMENT
   =================================================================== */
void WhileStatement(): {}
{
    <WHILE> ConditionList() CodeBlock()
}

void ConditionList(): {}
{
    Condition()
    | Condition() <COMMA> ConditionList()
}

void Condition(): {}
{
    Expression()
    | AvailabilityCondition()
    | CaseCondition()
    | OptionalBridgingCondition()
}

void CaseCondition(): {}
{
    <CASE> Pattern() Initializer()
}

void OptionalBridgingCondition(): {}
{
    <LET> Pattern() Initializer()
    | <VAR> Pattern() Initializer()
}


/* ===================================================================
                        4.5. GRAMMAR OF A REPEAT-WHILE STATEMENT
   =================================================================== */
void RepeatWhileStatement(): {}
{
    <REPEAT> CodeBlock() <WHILE> Expression()
}


/* ===================================================================
                        4.6. GRAMMAR OF A BRANCH STATEMENT
   =================================================================== */
void BranchStatement(): {}
{
    IfStatement()
    | GuardStatement()
    | SwitchStatement()
}


/* ===================================================================
                        4.7. GRAMMAR OF AN IF STATEMENT
   =================================================================== */
void IfStatement(): {}
{
    <IF> ConditionList() CodeBlock() (ElseClause())?
}

void ElseClause(): {}
{
    <ELSE> CodeBlock()
    | <ELSE> IfStatement()
}


/* ===================================================================
                        4.8. GRAMMAR OF A GUARD STATEMENT
   =================================================================== */
void GuardStatement(): {}
{
    <GUARD> ConditionList() <ELSE> CodeBlock()
}


/* ===================================================================
                        4.9. GRAMMAR OF A SWITCH STATEMENT
   =================================================================== */
void SwitchStatement(): {}
{
    <SWITCH> Expression() <OPEN_BRACKET> (SwitchCases())? <CLOSED_BRACKET>
}

void SwitchCases(): {}
{
    SwitchCase() (SwitchCases())?
}

void SwitchCase(): {}
{
    CaseLabel() Statements()
    | DefaultLabel() Statements()
}

void CaseLabel(): {}
{
    <CASE> CaseItemList() <COLON>
}

void CaseItemList(): {}
{
    Pattern() (WhereClause())?
    | Pattern() (WhereClause())? <COMMA> CaseItemList()
}

void DefaultLabel(): {}
{
    <DEFAULT> <COLON>
}

void WhereClause(): {}
{
    <WHERE> WhereExpression()
}

void WhereExpression(): {}
{
    Expression()
}


/* ===================================================================
                        4.10. GRAMMAR OF A LABELED STATEMENT
   =================================================================== */
void LabeledStatement(): {}
{
    StatementLabel() LoopStatement()
    | StatementLable() IfStatement()
    | StatementLable() SwitchStatement()
    | StatementLable() DoStatement()
}

void StatementLabel(): {}
{
    LabelName() <COLON>
}

void LabelName(): {}
{
    Identifier()
}


/* ===================================================================
                        4.11. GRAMMAR OF A CONTROL TRANSFER STATEMENT
   =================================================================== */
void ControlTransferStatement(): {}
{
    BreakStatement()
    | ContinueStatement()
    | FallthroughStatement()
    | ReturnStatement()
    | ThrowStatement()
}


/* ===================================================================
                        4.12. GRAMMAR OF A BREAK STATEMENT
   =================================================================== */



/* ===================================================================
                        4.13. GRAMMAR OF A CONTINUE STATEMENT
   =================================================================== */



/* ===================================================================
                        4.14. GRAMMAR OF A FALLTHROUGH STATEMENT
   =================================================================== */



/* ===================================================================
                        4.15. GRAMMAR OF A RETURN STATEMENT
   =================================================================== */



/* ===================================================================
                        4.16. GRAMMAR OF A THROW STATEMENT
   =================================================================== */



/* ===================================================================
                        4.17. GRAMMAR OF A DEFER STATEMENT
   =================================================================== */



/* ===================================================================
                        4.18. GRAMMAR OF A DO STATEMENT
   =================================================================== */



/* ===================================================================
                        4.19. GRAMMAR OF A COMPILER CONTROL STATEMENT
   =================================================================== */



/* ===================================================================
                        4.20. GRAMMAR OF A CONDITIONAL COMPILATION BLOCK
   =================================================================== */



/* ===================================================================
                        4.21. GRAMMAR OF A LINE CONTROL STATEMENT
   =================================================================== */



/* ===================================================================
                        4.22. GRAMMAR OF AN AVAILABILITY CONDITION
   =================================================================== */




/* =====================================================================================================================
                        5. Declarations
   ================================================================================================================== */


/* ===================================================================
                        5.1. GRAMMAR OF A DECLARATION
   =================================================================== */

void Declaration(): {}
{
    ImportDeclaration()
    | ConstantDeclaration()
    | VariableDeclaration()
    | TypealiasDeclaration()
    | FunctionDeclaration()
    | EnumDeclaration()
    | StructDeclaration()
    | ClassDeclaration()
    | ProtocolDeclaration()
    | InitializerDeclaration()
    | DeinitializerDeclaration()
    | ExtensionDeclaration()
    | SubscriptDeclaration()
    | OperatorDeclaration()
    | PrecedenceGroupDeclaration()
}

void Declarations(): {}
{
    Declaration() (Declarations())?
}

/* ===================================================================
                        5.2. GRAMMAR OF A TOP-LEVEL DECLARATION
   =================================================================== */

void TopLevelDeclaration(): {}
{
    (Statements())?
}

/* ===================================================================
                        5.3. GRAMMAR OF A CODE BLOCK
   =================================================================== */

void CodeBlock(): {}
{
    // TODO: brackets
    <DOT> <DOT>
}

/* ===================================================================
                        5.4. GRAMMAR OF AN IMPORT DECLARATION
   =================================================================== */



/* ===================================================================
                        5.5. GRAMMAR OF A CONSTANT DECLARATION
   =================================================================== */



/* ===================================================================
                        5.6. GRAMMAR OF A VARIABLE DECLARATION
   =================================================================== */



/* ===================================================================
                        5.7. GRAMMAR OF A TYPE ALIAS DECLARATION
   =================================================================== */



/* ===================================================================
                        5.8. GRAMMAR OF A FUNCTION DECLARATION
   =================================================================== */



/* ===================================================================
                        5.9. GRAMMAR OF AN ENUMERATION DECLARATION
   =================================================================== */



/* ===================================================================
                        5.10. GRAMMAR OF A STRUCTURE DECLARATION
   =================================================================== */



/* ===================================================================
                        5.11. GRAMMAR OF A CLASS DECLARATION
   =================================================================== */



/* ===================================================================
                        5.12. GRAMMAR OF A PROTOCOL DECLARATION
   =================================================================== */



/* ===================================================================
                        5.13. GRAMMAR OF A PROTOCOL PROPERTY DECLARATION
   =================================================================== */



/* ===================================================================
                        5.14. GRAMMAR OF A PROTOCOL METHOD DECLARATION
   =================================================================== */



/* ===================================================================
                        5.15. GRAMMAR OF A PROTOCOL INITIALIZER DECLARATION
   =================================================================== */



/* ===================================================================
                        5.16. GRAMMAR OF A PROTOCOL SUBSCRIPT DECLARATION
   =================================================================== */



/* ===================================================================
                        5.17. GRAMMAR OF A PROTOCOL ASSOCIATED DECLARATION
   =================================================================== */



/* ===================================================================
                        5.18. GRAMMAR OF AN INITIALIZER DECLARATION
   =================================================================== */



/* ===================================================================
                        5.19. GRAMMAR OF A DEINITIALIZER DECLARATION
   =================================================================== */



/* ===================================================================
                        5.20. GRAMMAR OF AN EXTENSION DECLARATION
   =================================================================== */



/* ===================================================================
                        5.21. GRAMMAR OF A SUBSCRIPT DECLARATION
   =================================================================== */



/* ===================================================================
                        5.22. GRAMMAR OF AN OPERATOR DECLARATION
   =================================================================== */



/* ===================================================================
                        5.23. GRAMMAR OF A PRECEDENCE GROUP DECLARATION
   =================================================================== */



/* ===================================================================
                        5.24. GRAMMAR OF A DECLARATION MODIFIER
   =================================================================== */




/* =====================================================================================================================
                        6. Attributes
   ================================================================================================================== */


/* ===================================================================
                        6.1. GRAMMAR OF AN ATTRIBUTE
   =================================================================== */

void Attribute(): {}
{
    <AT> AttributeName() (AttributeArgumentClause())?
}

void AttributeName(): {}
{
    Identifier()
}

void AttributeArgumentClause(): {}
{
    <OPEN_PARENTHESIS> (BalancedTokens())? <CLOSE_PARENTHESIS>
}

void Attributes(): {}
{
    Attribute() (Attributes())?
}

void BalancedTokens(): {}
{
    BalancedToken() (BalancedTokens())?
}

void BalancedToken(): {}
{
    <OPEN_PARENTHESIS> (BalancedTokens())? <CLOSE_PARENTHESIS>
    | <OPEN_SQUARE_BRACKET> (BalancedTokens())? <CLOSE_SQUARE_BRACKET>
    | <OPEN_BRACKET> (BalancedTokens())? <CLOSED_BRACKET>
    // TODO: Доделать

}

/* =====================================================================================================================
                        7. Patterns
   ================================================================================================================== */

/* ===================================================================
                        7.1. GRAMMAR OF A PATTERN
   =================================================================== */

void Pattern(): {}
{
    WildcardPattern() (TypeAnnotation())?
    | IdentifierPattern() (TypeAnnotation())?
    | ValueBindingPattern()
    | TuplePattern() (TypeAnnotation())?
    | EnumCasePattern()
    | OptionalPattern()
    | TypeCastingPattern()
    | ExpressionPattern()
}

/* ===================================================================
                        7.2. GRAMMAR OF A WILDCARD PATTERN
   =================================================================== */

void WildcardPattern(): {}
{
    <UNDERSCORE>
}

/* ===================================================================
                        7.3. GRAMMAR OF AN IDENTIFIER PATTERN
   =================================================================== */

void IdentifierPattern(): {}
{
    Identifier()
}

/* ===================================================================
                        7.4. GRAMMAR OF A VALUE-BINDING PATTERN
   =================================================================== */

void ValueBindingPattern(): {}
{
    <VAR> Pattern()
    | <LET> Pattern()
}

/* ===================================================================
                        7.5 GRAMMAR OF A TUPLE PATTERN
   =================================================================== */

void TuplePattern(): {}
{
    <OPEN_PARENTHESIS> (TuplePatternElementList())? <CLOSED_PARENTHESIS>
}

void TuplePatternElementList(): {}
{
    TuplePatternElement()
    | TuplePatternElement() <COMMA> TupleTypeElementList()
}

void TuplePatternElement(): {}
{
    Pattern()
    | Identifier() <COLON> Pattern()
}

/* ===================================================================
                        7.6. GRAMMAR OF AN ENUMERATION CASE PATTERN
   =================================================================== */

void EnumCasePattern(): {}
{
    (TypeIdentifier())? <DOT> EnumCaseName() (TuplePattern())?
}

/* ===================================================================
                        7.7. GRAMMAR OF AN OPTIONAL PATTERN
   =================================================================== */

void OptionalPattern(): {}
{
    IdentifierPattern() <QUESTION_MARK>
}


/* ===================================================================
                        7.8. GRAMMAR OF A TYPE CASTING PATTERN
   =================================================================== */

void TypeCastingPattern(): {}
{

}


/* ===================================================================
                        7.9. GRAMMAR OF AN EXPRESSION PATTERN
   =================================================================== */




/* =====================================================================================================================
                        8. Generic Parameters and Arguments
   ================================================================================================================== */


/* ===================================================================
                        8.1. GRAMMAR OF A GENERIC PARAMETER CLAUSE
   =================================================================== */
void GenericParameterClause(): {}
{
    <OPEN_TRIANGULAR_BRACKET> GenericParameterList() <CLOSED_TRIANGULAR_BRACKET>
}

void GenericParameterList(): {}
{
    GenericParameter()
    | GenericParameter() <COMMA> GenericParameterList()
}

void GenericParameter(): {}
{
    TypeName()
    | TypeName() <COLON> TypeIdentifier()
    | TypeName() <COLON> ProtocolCompositionType()
}

void GenericWhereClause(): {}
{
    <WHERE> RequirementList()
}

void RequirementList(): {}
{
    Requirement()
    | Requirement() <COMMA> RequirementList()
}

void Requirement(): {}
{
    ConformanceRequirement()
    | SameTypeRequirement()
}

void ConformanceRequirement(): {}
{
    TypeIdentifier() <COLON> TypeIdentifier()
    | TypeIdentifier() <COLON> ProtocolCompositionType()
}

void SameTypeRequirement(): {}
{
    TypeIdentifier() <EQUALS> Type()
}


/* ===================================================================
                        8.2. GRAMMAR OF A GENERIC ARGUMENT CLAUSE
   =================================================================== */

void GenericArgumentClause(): {}
{
    <OPEN_TRIANGULAR_BRACKET> GenericArgumentList() <CLOSED_TRIANGULAR_BRACKET>
}

void GenericArgumentList(): {}
{
    GenericArgument()
    | GenericArgument() <COMMA> GenericArgumentList()
}

void GenericArgument(): {}
{
    Type()
}